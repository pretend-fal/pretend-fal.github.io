<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[My late birthday wishes to Pxz]]></title>
    <url>%2F2018%2F08%2F25%2Fpxz%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>day by day</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪吃蛇 (C++)]]></title>
    <url>%2F2018%2F08%2F07%2F%E8%B4%AA%E5%90%83%E8%9B%87%20(C%2B%2B)%2F</url>
    <content type="text"><![CDATA[这是我花了两个小时才完成的 玩法： 第一次输入是地图的大小、地图是正方形 第二次是速度，即蛇两次移动的时间间隔=输入的数字*0.1s 如发现 bug 请联系我 QQ：1208247864 邮箱：1208247864@qq.com 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;bits/stdc++.h&gt;#include &lt;conio.h&gt;#include &lt;windows.h&gt;using namespace std;int n,mid=100,dif,headx,heady,flag,score;int bx[]=&#123;0,-1,1,0,0&#125;, by[]=&#123;0,0,0,-1,1&#125;;int dox[15][15], doy[15][15], upx[15][15], upy[15][15], End[15][15];char che[15][15];int Get () &#123; int res=0; char ch; do &#123; ch=getch (); switch (ch) &#123; case 72 : res=1; break ; case 80 : res=2; break ; case 75 : res=3; break ; case 77 : res=4; break ; default : break ; &#125; &#125; while (!res) ; return res;&#125;void Clean () &#123; system ("cls"); return ;&#125;void Out () &#123; HANDLE hout=GetStdHandle(STD_OUTPUT_HANDLE); Clean (); printf ("Your score : %d\n",score); for (int i=1;i&lt;=n;i++) printf("__"); puts (""); for (int i=1;i&lt;=n;i++) &#123; printf ("|"); for (int j=1;j&lt;=n;j++) &#123; if (che[i][j]=='@') &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED);// 红色 printf("%c",che[i][j]); SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);//三色相加，白色 printf("|"); &#125; else if (che[i][j]=='#') &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE);//绿色和蓝色相加，青色 printf("%c",che[i][j]); SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);//三色相加，白色 printf("|"); &#125; else if (che[i][j]=='+') &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN);//红色和绿色相加，黄色 printf("%c",che[i][j]); SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);//三色相加，白色 printf("|"); &#125; else printf("%c|",che[i][j]); &#125; puts (""); for (int j=1;j&lt;=n;j++) printf("__"); puts (""); &#125;&#125;/* + @######## */void Food () &#123; int x,y; do &#123; x=rand()%n+1; y=rand()%n+1; &#125; while (che[x][y]!=' '); che[x][y]='+'; return ;&#125;void Be () &#123; puts ("input a number which as the length of chessboard."); puts ("warning !!! the number should smaller than ten."); scanf ("%d",&amp;n); Clean (); puts ("Enter a number(1~10) to determine the difficulty of the game."); puts ("The time interval is the input number *100ms."); scanf("%d",&amp;dif); mid*=dif; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) che[i][j]=' '; int x=rand()%n+1, y=rand()%n+1; che[x][y]='@'; End[x][y]=1; headx=x; heady=y; flag=rand()%4+1; do &#123; x=headx+bx[flag]; y=heady+by[flag]; if (x &amp;&amp; y &amp;&amp; x&lt;=n &amp;&amp; y&lt;=n) break ; flag=(flag+1)%4; if (!flag) flag=1; &#125; while (1) ; Food (); Out ();&#125;void is_fail (int x,int y) &#123; if (!x || !y || x&gt;n || y&gt;n || (che[x][y]!=' ' &amp;&amp; che[x][y]!='+')) &#123; puts ("Emnnnnnn......"); puts ("Game Over"); system ("pause"); exit(0); &#125; return ;&#125;void Eat (int x,int y) &#123; score+=10-dif+1; che[x][y]='@'; che[headx][heady]='#'; upx[headx][heady]=x; upy[headx][heady]=y; dox[x][y]=headx; doy[x][y]=heady; headx=x; heady=y; Food ();&#125;void Go (int x) &#123; int tox=headx+bx[x], toy=heady+by[x]; is_fail (tox,toy); if (che[tox][toy]=='+') Eat (tox,toy); else &#123; upx[headx][heady]=tox; upy[headx][heady]=toy; dox[tox][toy]=headx; doy[tox][toy]=heady; che[headx][heady]='#'; che[tox][toy]='@'; headx=tox; heady=toy; while (!End[tox][toy]) &#123; int nowx=dox[tox][toy]; int nowy=doy[tox][toy]; if (End[nowx][nowy]) &#123; che[nowx][nowy]=' '; End[nowx][nowy]=0; End[tox][toy]=1; break ; &#125; tox=nowx; toy=nowy; &#125; &#125; Out (); return ;&#125;void Move () &#123; double l=clock (); int tim=1; while ((tim=(clock()-l&lt;mid)) &amp;&amp; !kbhit ()) ; if(!tim) &#123; Go (flag); return ; &#125; int want=Get (); if (want==1 &amp;&amp; flag==2) return ; if (want==2 &amp;&amp; flag==1) return ; if (want==3 &amp;&amp; flag==4) return ; if (want==4 &amp;&amp; flag==3) return ; flag=want; Go (flag); return ;&#125;int main ()&#123; srand (time(0)); Be (); while (1) Move ();&#125;]]></content>
      <tags>
        <tag>C++ 乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组浅谈]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[由于一时兴起，许诺要写一篇关于后缀数组的blog，不知道哪里来的勇气 废话不多说，我们开始乱讲后缀数组 [TOC] 1.前言后缀数组和后缀树 在字符串处理当中，后缀树和后缀数组都是非常有力的工具。其实后缀数组是后缀树的一个非常精巧的替代品，它比后缀树容易编程实现，能够实现后缀树的很多功能而时间复杂度也不太逊色，并且，它比后缀树所占用的空间小很多。可以说，在信息学竞赛中后缀数组比后缀树要更为实用。——百度百科 然而我不是很会后缀树。。。。。。。。。 各种定义子串： 就是子串[捂脸] 后缀： 就是从 $i$ 这个位置开始到该字符串的末尾的一个子串 字符串大小： $a$ 和 $b$ 这两个串，从头开始逐个字符按照ASSIC码进行比较 后缀数组： $sa[i]$代表该字符串的$len$个后缀中，排名为 $i$ 的后缀是第$sa[i]$个后缀 名词数组： $rank[i]$代表第 $i$ 个后缀排名为$rank[i]$ 2.一些构造方法最简单的暴力硬sort 就是把所有的后缀拆出来，然后sort 思想极其简单，没什么可说的 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int rank[123], sa[123];struct Str &#123; string s; int wei; friend bool operator &lt; (Str a1,Str a2) &#123; return a1.s&lt;a2.s; &#125;&#125; k[123] ;int main()&#123; string s; cin &gt;&gt; s; int len=s.size()-1; for (int i=0;i&lt;=len;i++) &#123; k[i].wei=i; for (int j=i;j&lt;=len;j++) k[i].s=k[i].s+s[j]; &#125; sort (k,k+len+1); for (int i=0;i&lt;=len;i++) &#123; rank[k[i].wei]=i; sa[i]=k[i].wei; &#125; exit(0);&#125; 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 是不是觉得代码写得一本正经？？！！然而这是我直接打的，没运行，没Debug，想写的话自己练习。。。。。。。。。。。 倍增这个就是一般人写后缀数组用的方法，我是一般人 复杂度是 $O(nlogn)$ ，毕竟都倍增了。。。。。。。。。 奥对，你要先会基数排序才行。。。。。。不会的可以自行Google 假设我们有这样一个字符串 aabaaaab 然后我们把所有的后缀列举出来： 然后用基数排序的方式，按照每个后缀的第一个字母进行排序，呈现这样子的效果： 接着我们以第二个字母为关键字，在首字母有序的基础上进行排序，这个时候，我们把首字母相同的后缀拿出来单看 对于每一组首字母相同的后缀，首字母是对排序没有影响的，所以可以直接按照第二个字母进行基数排序，同样，对于首字母不同的后缀，由于按照首字母排序时，他们的相对大小已经确定，当按照第二个字母排序时，不会出现原来a&gt;b，现在b&gt;a的现象，所以我们可以看成一直在做区域内的排序，这之后变成这样： 第三字母同理…….. 这样子我们可以处理这个问题，可是复杂度还是没有到达一个我们可以接受的范围 所以我们引入倍增 当我们按照每个后缀的前 $2^k$个字母进行完排序后，那么我们把后缀的前 $2^{k+1}$看做前后两个 $2^k$,这样我们就可以把这前后两个 $2^k$作为之前说的首字母和第二个字母了，然后进行上述过程，就可以在 $O(nlogn)$ 的复杂度内处理这个问题了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;int n;int sa[150], x[150], c[150], y[150];char a[150];inline void SA () &#123; int m=128; for (int i=0;i&lt;=m;i++) c[i]=0; for (int i=1;i&lt;=n;i++) c[x[i]]++; for (int i=1;i&lt;=m;i++) c[i]+=c[i-1]; for (int i=n;i;i--) sa[c[x[i]]--]=i; for (int k=1,p;k&lt;=n;k&lt;&lt;=1) &#123; p=0; for (int i=n;i&gt;n-k;i--) y[++p]=i; for (int i=1;i&lt;=n;i++) if(sa[i]&gt;k) y[++p]=sa[i]-k; for (int i=0;i&lt;=m;i++) c[i]=0; for (int i=1;i&lt;=n;i++) c[x[i]]++; for (int i=1;i&lt;=m;i++) c[i]+=c[i-1]; for (int i=n;i;i--) sa[c[x[y[i]]]--]=y[i]; p=y[sa[1]]=1; for (int i=2,a,b;i&lt;=n;i++) &#123; a=sa[i]+k&gt;n ? -1 : x[sa[i]+k]; b=sa[i-1]+k&gt;n ? -1 : x[sa[i-1]+k]; y[sa[i]]= (x[sa[i]]==x[sa[i-1]]) &amp;&amp; (a==b) ? p : ++p ; &#125; swap (x,y); m=p; &#125;&#125;int main () &#123; scanf("%s",a+1); n=strlen (a+1); for (int i=1;i&lt;=n;i++) x[i]=a[i]; SA (); for (int i=1;i&lt;=n;i++) printf("%d ",sa[i]); exit(0);&#125; 代码里 $x[i]$ 就是 $rank[i]$ $y[i]$ ：假设 $y[i]=a , y[i+1]=b$ 那么在原串中 从$a+2^k$开始的$2^k$个字符组成的子串 小于等于 从$b+2^k$开始的$2^k$个字符组成的子串 就没了，最好理解这个代码时，每一步都结合这基数排序来考虑 拜拜]]></content>
      <tags>
        <tag>algorithm of OI</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fixed之后的一些话]]></title>
    <url>%2F2018%2F08%2F01%2Ffixed%E4%B9%8B%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[ennnn 首先感谢某石姓男子，在他的辅助下，我修好了这个崩了很久的blog 然后呢，其实我早就想写点什么东西了，虽然没什么文采，但是还是可以胡咧咧两句的 [咧嘴笑] 先放几张图吧，然后回忆回忆自己经历的事情 这是我升高三的时候的成绩，总分$442$，确实是特别差，(早知道就再考差点，没准就不会分在李明刚班了呢。。。。) 当时觉得woc，这么低，怎么搞的，什么鬼，woc，然后心里除了怀疑就是沮丧和无奈，但是这一切都比不过得知被分到李明刚班时的那种难以表达的感觉，然后，我就顶着这样的分数进了普通班，心情沉重，因为我是从奥赛出来的，可能大家都觉得那个地方的人成绩会十分的棒，其实，我心里的难受也有很大一部分是来自这里——我怕因为我的成绩让大家看不起奥赛这两个字(希望不会，班里的同学们都挺可爱的)。接着，我就和大家一起学习了，由于是桃城区的学生组成的级部，我在班里还是有一些认识的人的，至少我周围的人我大概都认识(十分的巧，哈哈哈)，老师和同学们我没什么说的，就这样过了半个月，迎来了我和高三有关的第二次考试——一调，和我关系好的人大概都知道，我心里其实是有骄傲的，来自奥赛的身份、心气高都让我十分的骄傲，但是我的成绩又不允许我把这份骄傲放出来，所以我有些着急，就这样，我考完了一调 这是一调的成绩，总分$487$ ，比上一次提了$45$分，可能听起来$45$分不少，但是啊，$487$分是真的低，但我还是因为这$45$分开心了一下，可当我知道某石姓男子考了800多名、YYdalao考了300多名时，以及各种600分。。。1600多名的我内心只有一个念头：才半个月，怎么会差这么多？！！我心慌了，但是我依旧没有努力，也许这就是我会这么差的原因吧，可能我回去的时间要比他们晚一些吧，我这里用的是晚一些，因为我一定要回去，毕竟在我心里，那里才是奥赛生应该在的地方(我想离开李明刚)，就这样过了几天，我得知我们还会再有一次考试，我很兴奋，可又害怕，但是我没办法，一件让我欲推还就的事情，我真的不知道怎么去面对，但是不知道哪里来的底气，我竟然极有信心，日子一天天过去了，虽然我认识的人并没有变得很多，但是大家都知道了班里有一个人是学奥赛的，这样，慢慢地到了考试的日子，再此之前还有一次周测，据说DK考了他们级部前五，我得知时笑了，内心并没有什么想法，或许有祝贺，有羡慕，再或者，有渴望。终于二调了 这是二调成绩，今天刚查的$584$，提了$97$分，可能感觉不少，可是并不会高兴，因为我犯贱问了几个成绩好的同学，本来打算看看差多少，结果差的有点多：YY$634$、DK$635$，不过还好，并不会感觉怎么样，还OK吧，今天开始集训了，至于奥赛，我可以说我是个经历过失败的人，从去年noip没拿到省一之后，省选几经挫折，甚至崩溃，还是没能翻盘，再到APIO和CTSC，没有省一，参加不了CTSC，APIO打铁回归，其实我感觉我的OI路就是一路跪过来的，所以失败什么的，我真的经历的太多了，今年还有一次noip，可能是有了阴影吧，心里又期待，又害怕，但是心里还有信心，真是个奇怪的心理 奥对，今天还查作业了，要是早知道可以进班写作业，我就不进校之后去操场瞎jb溜达了。。。。。。。。。。 今天又学了一下怎么写网站，然而学会了一点点，但是连皮毛都算不上，也就自己乐呵乐呵了 好了，就先说这些吧，最后用一句话来结束好了——愿我的明天便是我想要的未来 五洲沛 2018.08.01于机房]]></content>
      <tags>
        <tag>day by day</tag>
        <tag>mood</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[狗屁的梦想]]></title>
    <url>%2F2018%2F06%2F18%2F%E7%8B%97%E5%B1%81%E7%9A%84%E6%A2%A6%E6%83%B3%2F</url>
    <content type="text"><![CDATA[1#define bt 变态 今天又上奥赛了，十分的不容易，这一切还是要从分班说起 我被分到了18班，一开始我们奥赛几个知道的比较晚，所以我们分班搬书换宿舍也就晚一些，然后搬完了东西我也不知道我的班主任是谁，后来在我到处问我是哪个宿舍的时候，偶然知道我的班主任是——李明刚！！！ 当时就感觉woc，完了 事实证明，感觉真的没错 我进班还没五分钟就被他骂了一次，把全班都吓到了，原因十分令人费解——我回答他的问题的时候用的是“啊”这个语气词，woc，神经病吧，令我十分生气 然后就在这种bt班主任的带领下，成功崩溃了，我感觉什么特么梦想，什么特么希望，全是假的，就只有绝望、恐惧、腻歪、想逃跑 我昨天说来上奥赛，他说没接到通知，不让来，ojbk，生气而且心灰意泠，今天孔哥给他发信息了，然后我就来了 我找了孔哥，我问我还有没有可能回到高三，大概这个问题被含糊过去了，我问我能不能离开李明刚的班，他说途径只有一条，考好了，调到实验班 我很开心，至少还有希望，放心吧，我一定会在最短的时间内达到一个足够的高度，逃离李明刚，什么特么狗屁的梦想，离开李明刚才是王道 300 我一定会进300 的 狗屁的梦想，我要离开李明刚这个bt 我也没有想到刚刚升入高三就会这么cao dan，我现在真的有些崩溃了，这个老师太尼玛bt了，熬，就是熬，我一定要离开他 额啊啊啊啊啊啊啊啊啊啊 fighting 2018.06.18]]></content>
      <tags>
        <tag>day by day</tag>
        <tag>mood</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高三前的话]]></title>
    <url>%2F2018%2F06%2F14%2F%E9%AB%98%E4%B8%89%E5%89%8D%E7%9A%84%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[刚刚考完了期末，一场所谓的联考，可能是联考吧，反正我不知道联考的有哪些学校 考完这场试，我的高二就差不都结束了，等待着分班，这时候我才愿意接受“高三狗”这个名号 打饭前，也就是考完了英语之后，回到了教室，少有的心情简单，大概是还不明白自己这次考得什么样吧。发了答案，就少有的立刻对了答案，可能心里还有些侥幸吧，对着答案，心里就凉了，神特么化学生物，一面选择就对一个是什么鬼，woc，凉凉，尬了半天，到了最后一节课，fkx说要听听力，就回去了，并没有听听力，但是有英语答案，狠心对了英语，听力错了10个，CD篇就对了一个，完型8个，我日，总体算下来，除了作文之外的125分，我大概只能拿82分，心情更加简单。。。。 然后我就在想，这操蛋的生活啊，但是我现在面对的只是一些烦恼，可能并不能称之为生活，然后我就暂且打算称这些为成长的烦恼了，大概这是一个人在生命中必须要经历的阶段吧，烦恼，无非是一些自己并不喜欢的事情，但是又无法改变，或者说改变起来十分困难，但是真的需要改变，不然得不到自己想要的，心里会十分不舒服，我当时看着外面，天气十分的棒，“deal with”，脑子里一闪而过的一个词语，但是我抓住了，那一刻我突然有了对成长的定义：解决。 去解决一切会妨碍自己得到自己想要的事情，这个解决可以是努力去使这个事情改变，向着自己想要的样子改变，或者藏在心里，就像除了成绩之外的那些人们称之为成长的烦恼的事情，藏起来，假装谁也不知道，但是这样子就有一些侥幸心理了，忘了最好，化成一段回忆也好，但是万一成为了一个想起来就痛的事情，就十分的令人难过了，但愿我现在所选择藏起来的事情可以成为将来的美好回忆，因为我有太多的遗憾了，每一个都令人痛心 将来还是自己的，这句话我现在依旧感觉有些大，有些空，但是可能这是真的吧，我现在所努力的方向，但愿有着宝藏，若没有，那就把方向变成诗和远方吧，至少不枉我努力一场。这句话，希望将来说出口的时候不会感到尴尬和心虚 看到这篇文章的同学，倒不如说是读者，共勉吧，生活真的不只有眼前的苟且，还有你自己的方向和内心那藏着掖着的、腼腆的倔强 2018.06.14 于机房]]></content>
      <tags>
        <tag>day by day</tag>
        <tag>mood</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2048 (c++)]]></title>
    <url>%2F2018%2F05%2F08%2F2048%20(C%2B%2B)%2F</url>
    <content type="text"><![CDATA[这是原版，然后后面有一个升级版，全是我写的，要是有 $bug$ 可以QQ反馈给我， ennnnnnnn QQ：1208247864 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include &lt;bits/stdc++.h&gt;#include &lt;conio.h&gt;#include &lt;windows.h&gt;#define II int#define IL inline#define R registerusing namespace std;II len,ans;II a[6][6], p[6], cant[6];int Get()&#123; int ret = 0; do &#123; int ch = getch(); ch = getch(); switch(ch) &#123; case 72: ret = 1; break;// top 定义数字上 case 80: ret = 2; break;// down 定义数字下 case 75: ret = 3; break;// left 定义数字左 case 77: ret = 4; break;// right 定义数字右 default: break; &#125; &#125; while (ret == 0); return ret;&#125;IL void pr(R II x) &#123; HANDLE hout=GetStdHandle(STD_OUTPUT_HANDLE); if(x==2 || x==4) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); printf("%5d ",x); &#125; if(x==8) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED); printf("%5d ",x); &#125; if(x==16) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_GREEN);//绿色 printf("%5d ",x); &#125; if(x==32) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_BLUE);//蓝色 printf("%5d ",x); &#125; if(x==64) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN);//红色和绿色相加，黄色 printf("%5d ",x); &#125; if(x==128) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_BLUE);//红色和蓝色相加，粉色 printf("%5d ",x); &#125; if(x==256) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE);//绿色和蓝色相加，青色 printf("%5d ",x); &#125; if(x==512) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY);//没有添加颜色，原色 printf("%5d ",x); &#125; if(x==1024) &#123; SetConsoleTextAttribute(hout,79); printf("%5d ",x); &#125; if(x==2048) &#123; SetConsoleTextAttribute(hout,176); printf("%5d ",x); &#125; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);//三色相加，白色 return ;&#125;IL void Clear() &#123; system("cls"); &#125;IL int Top() &#123; R II flag=0; for(R II j=1;j&lt;=4;j++) &#123; len=0; for(R II i=0;i&lt;=4;i++) cant[i]=0; for(R II i=1;i&lt;=4;i++) if(a[i][j]) &#123; if(!a[i-1][j] &amp;&amp; i&gt;1) flag=1; p[++len]=a[i][j]; if(p[len]==p[len-1] &amp;&amp; !cant[len-1]) &#123; flag=1; p[len-1]&lt;&lt;=1; len--; ans+=p[len]; cant[len]=1; &#125; a[i][j]=0; &#125; for(R II i=1;i&lt;=len;i++) a[i][j]=p[i]; &#125; return flag;&#125;IL int Down() &#123; R II flag=0; for(R II j=1;j&lt;=4;j++) &#123; len=5; for(R II i=0;i&lt;=4;i++) cant[i]=0; for(R II i=4;i;i--) if(a[i][j]) &#123; if(!a[i+1][j] &amp;&amp; i&lt;4) flag=1; p[--len]=a[i][j]; if(p[len]==p[len+1] &amp;&amp; !cant[len+1]) &#123; flag=1; p[len+1]&lt;&lt;=1; len++; ans+=p[len]; cant[len]=1; &#125; a[i][j]=0; &#125; for(R II i=4;i&gt;=len;i--) a[i][j]=p[i]; &#125; return flag;&#125;IL int Left() &#123; R II flag=0; for(R II i=1;i&lt;=4;i++) &#123; len=0; for(R II j=0;j&lt;=4;j++) cant[j]=0; for(R II j=1;j&lt;=4;j++) &#123; if(a[i][j]) &#123; if(!a[i][j-1] &amp;&amp; j&gt;1) flag=1; p[++len]=a[i][j]; if(p[len]==p[len-1] &amp;&amp; !cant[len-1]) &#123; flag=1; p[len-1]&lt;&lt;=1; len--; ans+=p[len]; cant[len]=1; &#125; a[i][j]=0; &#125; for(R II j=1;j&lt;=len;j++) a[i][j]=p[j]; &#125; &#125; return flag;&#125;IL int Reight() &#123; R II flag=0; for(R II i=1;i&lt;=4;i++) &#123; len=5; for(R II j=0;j&lt;=5;j++) cant[j]=0; for(R II j=4;j;j--) if(a[i][j]) &#123; if(!a[i][j+1] &amp;&amp; j&lt;4) flag=1; p[--len]=a[i][j]; if(p[len]==p[len+1] &amp;&amp; !cant[len+1]) &#123; flag=1; p[len+1]&lt;&lt;=1; len++; ans+=p[len]; cant[len]=1; &#125; a[i][j]=0; &#125; for(R II j=4;j&gt;=len;j--) a[i][j]=p[j]; &#125; return flag;&#125;IL void New() &#123; R II flag=0; for(R II i=1;i&lt;=4;i++) for(R II j=1;j&lt;=4;j++) if(!a[i][j]) &#123; flag=1; break ; &#125; while (flag) &#123; R II x=rand()%4+1, y=rand()%4+1; if(!a[x][y]) &#123; a[x][y]=(rand()%2+1)&lt;&lt;1; return ; &#125; &#125;&#125;IL void out() &#123; Clear(); printf("now your score is : %d \n\n",ans); for(R II i=1;i&lt;=4;i++, puts("")) &#123; for(R II j=1;j&lt;=30;j++) printf("-"); puts(""); for(R II j=1;j&lt;=4;j++) &#123; printf("|");// if(a[i][j]) printf("%5d ",a[i][j]); if(a[i][j]) pr(a[i][j]); else printf(" "); &#125; printf("|"); &#125; for(R II j=1;j&lt;=30;j++) printf("-");&#125;IL void Fail() &#123; out(); puts("THE GAME END"); printf("Your score is %d \n",ans); exit(0);&#125;IL void begin() &#123; R II x=rand()%3+1; while (x--) New(); out();&#125;IL bool all() &#123; for(R II i=1;i&lt;=4;i++) for(R II j=1;j&lt;=4;j++) if(!a[i][j]) return 1; return 0;&#125;IL bool cango() &#123; for(R II i=1;i&lt;=4;i++) for(R II j=1;j&lt;=4;j++) &#123; if(!a[i][j]) continue ; for(R II k=i-1;k;k--) if(a[k][j]) &#123; if(a[k][j]==a[i][j]) return 1; break ; &#125; for(R II k=i+1;k&lt;=4;k++) if(a[k][j]) &#123; if(a[k][j]==a[i][j]) return 1; break ; &#125; for(R II k=j-1;k;k--) if(a[i][k]) &#123; if(a[i][k]==a[i][j]) return 1; break ; &#125; for(R II k=j+1;k&lt;=4;k++) if(a[i][k]) &#123; if(a[i][k]==a[i][j]) return 1; break ; &#125; &#125; return 0;&#125;IL bool can() &#123; if(all()) return 1; if(cango()) return 1; return 0;&#125;int main()&#123; srand(time(0)); begin(); int s,Do,lc; while (s=Get()) &#123; /* move */ if(s==1) Do=Top(); if(s==2) Do=Down(); if(s==3) Do=Left(); if(s==4) Do=Reight(); /* test */ if(!can()) Fail(); /* out */ if(Do || !all()) New(); out(); &#125; system("pause"); return 0;&#125; 然后是升级版 每次新出现的数范围变大，(如果第一个你输入了1，0则不会变大) TV模式，你就自己看着就好了，(如果你第二个输入了1，0则不变) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309#include &lt;bits/stdc++.h&gt;#include &lt;conio.h&gt;#include &lt;windows.h&gt;#define II int#define IL inline#define R registerusing namespace std;II len,ans,n,VIP,TV;II a[200][200], p[200], cant[200];int Get()&#123; if(TV) return rand()%4+1; int ret = 0; do &#123; int ch = getch(); ch = getch(); switch(ch) &#123; case 72: ret = 1; break;// top 定义数字上 case 80: ret = 2; break;// down 定义数字下 case 75: ret = 3; break;// left 定义数字左 case 77: ret = 4; break;// right 定义数字右 default: break; &#125; &#125; while (ret == 0); return ret;&#125;IL void pr(R II x) &#123; HANDLE hout=GetStdHandle(STD_OUTPUT_HANDLE); if(x==2 || x==4) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); printf("%5d ",x); &#125; if(x==8) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED); printf("%5d ",x); &#125; if(x==16) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_GREEN);//绿色 printf("%5d ",x); &#125; if(x==32) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_BLUE);//蓝色 printf("%5d ",x); &#125; if(x==64) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN);//红色和绿色相加，黄色 printf("%5d ",x); &#125; if(x==128) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_BLUE);//红色和蓝色相加，粉色 printf("%5d ",x); &#125; if(x==256) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE);//绿色和蓝色相加，青色 printf("%5d ",x); &#125; if(x==512) &#123; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY);//没有添加颜色，原色 printf("%5d ",x); &#125; if(x==1024) &#123; SetConsoleTextAttribute(hout,79); printf("%5d ",x); &#125; if(x==2048) &#123; SetConsoleTextAttribute(hout,176); printf("%5d ",x); &#125; if(x==4096) &#123; SetConsoleTextAttribute(hout,140); printf("%5d ",x); &#125; if(x&gt;4096) &#123; R II k=rand()%200+1; SetConsoleTextAttribute(hout,k); printf("%5d ",x); &#125; SetConsoleTextAttribute(hout,FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);//三色相加，白色 return ;&#125;IL void Clear() &#123; system("cls"); &#125;IL int Top() &#123; R II flag=0; for(R II j=1;j&lt;=n;j++) &#123; len=0; for(R II i=0;i&lt;=n;i++) cant[i]=0; for(R II i=1;i&lt;=n;i++) if(a[i][j]) &#123; if(!a[i-1][j] &amp;&amp; i&gt;1) flag=1; p[++len]=a[i][j]; if(p[len]==p[len-1] &amp;&amp; !cant[len-1]) &#123; flag=1; p[len-1]&lt;&lt;=1; len--; ans+=p[len]; cant[len]=1; &#125; a[i][j]=0; &#125; for(R II i=1;i&lt;=len;i++) a[i][j]=p[i]; &#125; return flag;&#125;IL int Down() &#123; R II flag=0; for(R II j=1;j&lt;=n;j++) &#123; len=n+1; for(R II i=0;i&lt;=n;i++) cant[i]=0; for(R II i=n;i;i--) if(a[i][j]) &#123; if(!a[i+1][j] &amp;&amp; i&lt;n) flag=1; p[--len]=a[i][j]; if(p[len]==p[len+1] &amp;&amp; !cant[len+1]) &#123; flag=1; p[len+1]&lt;&lt;=1; len++; ans+=p[len]; cant[len]=1; &#125; a[i][j]=0; &#125; for(R II i=n;i&gt;=len;i--) a[i][j]=p[i]; &#125; return flag;&#125;IL int Left() &#123; R II flag=0; for(R II i=1;i&lt;=n;i++) &#123; len=0; for(R II j=0;j&lt;=n;j++) cant[j]=0; for(R II j=1;j&lt;=n;j++) &#123; if(a[i][j]) &#123; if(!a[i][j-1] &amp;&amp; j&gt;1) flag=1; p[++len]=a[i][j]; if(p[len]==p[len-1] &amp;&amp; !cant[len-1]) &#123; flag=1; p[len-1]&lt;&lt;=1; len--; ans+=p[len]; cant[len]=1; &#125; a[i][j]=0; &#125; for(R II j=1;j&lt;=len;j++) a[i][j]=p[j]; &#125; &#125; return flag;&#125;IL int Reight() &#123; R II flag=0; for(R II i=1;i&lt;=n;i++) &#123; len=n+1; for(R II j=0;j&lt;=n+1;j++) cant[j]=0; for(R II j=n;j;j--) if(a[i][j]) &#123; if(!a[i][j+1] &amp;&amp; j&lt;n) flag=1; p[--len]=a[i][j]; if(p[len]==p[len+1] &amp;&amp; !cant[len+1]) &#123; flag=1; p[len+1]&lt;&lt;=1; len++; ans+=p[len]; cant[len]=1; &#125; a[i][j]=0; &#125; for(R II j=n;j&gt;=len;j--) a[i][j]=p[j]; &#125; return flag;&#125;IL void New() &#123; R II flag=0; for(R II i=1;i&lt;=n;i++) for(R II j=1;j&lt;=n;j++) if(!a[i][j]) &#123; flag=1; break ; &#125; while (flag) &#123; R II x=rand()%n+1, y=rand()%n+1; if(!a[x][y]) &#123; if(VIP) a[x][y]=1&lt;&lt;(rand()%11+1); else a[x][y]=(rand()%2+1)&lt;&lt;1; return ; &#125; &#125;&#125;IL void out() &#123; Clear(); printf("now your score is : %d \n\n",ans); for(R II i=1;i&lt;=n;i++, puts("")) &#123; for(R II j=1;j&lt;=n*7+1;j++) printf("-"); puts(""); for(R II j=1;j&lt;=n;j++) &#123; printf("|");// if(a[i][j]) printf("%5d ",a[i][j]); if(a[i][j]) pr(a[i][j]); else printf(" "); &#125; printf("|"); &#125; for(R II j=1;j&lt;=n*7+1;j++) printf("-");&#125;IL void Fail() &#123; out(); puts("\nTHE GAME END"); printf("Your score is %d \n",ans); system("pause"); exit(0);&#125;IL void begin() &#123; R II x=rand()%3+1; while (x--) New(); out();&#125;IL bool all() &#123; for(R II i=1;i&lt;=n;i++) for(R II j=1;j&lt;=n;j++) if(!a[i][j]) return 1; return 0;&#125;IL bool cango() &#123; for(R II i=1;i&lt;=n;i++) for(R II j=1;j&lt;=n;j++) &#123; if(!a[i][j]) continue ; for(R II k=i-1;k;k--) if(a[k][j]) &#123; if(a[k][j]==a[i][j]) return 1; break ; &#125; for(R II k=i+1;k&lt;=n;k++) if(a[k][j]) &#123; if(a[k][j]==a[i][j]) return 1; break ; &#125; for(R II k=j-1;k;k--) if(a[i][k]) &#123; if(a[i][k]==a[i][j]) return 1; break ; &#125; for(R II k=j+1;k&lt;=n;k++) if(a[i][k]) &#123; if(a[i][k]==a[i][j]) return 1; break ; &#125; &#125; return 0;&#125;IL bool can() &#123; if(all()) return 1; if(cango()) return 1; return 0;&#125;int main()&#123; puts("input a n, n&lt;=15 "); scanf("%d",&amp;n); puts("do you want the new number is bigger ? input 1/0"); scanf("%1d",&amp;VIP); puts("do you want to play the game like watching TV ? input 1/0"); scanf("%1d",&amp;TV); srand(time(0)); begin(); int s,Do,lc; while (s=Get()) &#123; /* move */ if(s==1) Do=Top(); if(s==2) Do=Down(); if(s==3) Do=Left(); if(s==4) Do=Reight(); /* test */ if(!can()) Fail(); /* out */ if(Do || !all()) New(); out(); &#125; system("pause"); return 0;&#125; END]]></content>
      <tags>
        <tag>games</tag>
        <tag>C++ 乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for_lxw]]></title>
    <url>%2F2018%2F04%2F29%2Ffor_lxw%2F</url>
    <content type="text"><![CDATA[if("llxwei"==prompt("请输入密码")) { alert("正确"); } else { alert("错误"); location="http://pretend-fal.ml/"; } 忘记了哪天相遇我们互不相识后来我们熟悉了彼此以一个我现在又庆幸有后悔的关系开始了我们之间的磕磕绊绊 后来啊你转了学我们便再也没了什么话 又是一个我忘了的日子你找我要备注然后开启了我们之间的新的一页 这一页上我开心于有你的陪伴不知不觉我们都大了虽然不想承认但是抵不住似水年华 最近是各所学校强加给高二人的成人礼但是这真的让人有些醒悟至少正视了自己的年龄隐隐约约的知道了自己面临的是什么 狗子我觉得成人并不快乐但是希望你能有 最少的烦恼最多的笑容和虽然不可爱但是现在是最可爱的我]]></content>
      <tags>
        <tag>day by day</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各类模板(日常更新)]]></title>
    <url>%2F2018%2F04%2F22%2F%E5%90%84%E7%B1%BB%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[这篇Blog是一些板子。。。。。。。。。。。。。。 [TOC] #高精 + - * 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define II long long#define IL inline#define R register#define I 1010#define PI 10using namespace std;template &lt; typename T &gt; IL void of (R T &amp;a) &#123; R char c=getchar (); R T w=1, p=0; while (!isdigit(c)) &#123; if(c=='-') w=-1; c=getchar (); &#125; while (isdigit(c)) &#123; p=p*10+c-'0'; c=getchar (); &#125; a=w*p;&#125;/* -------------------- Peipei -------------------- */char s[I];struct NU &#123; II a[I]; NU () &#123;memset(a,0,sizeof a);&#125; IL void in() &#123; scanf("%s",s+1); a[0]=strlen(s+1); for(R II i=a[0];i;i--) a[a[0]-i+1]=s[i]-'0'; &#125; friend NU operator + (NU a1,NU a2) &#123; R NU c; R II jin=0; c.a[0]=max(a1.a[0],a2.a[0]); for(R II i=1;i&lt;=c.a[0];i++) &#123; c.a[i]=a1.a[i]+a2.a[i]+jin; jin=c.a[i]/PI; c.a[i]%=PI; &#125; while (jin) c.a[++c.a[0]]=jin%PI, jin/=PI; return c; &#125; friend NU operator - (NU a1,NU a2) &#123; R NU c=a1; for(R II i=1;i&lt;=c.a[0];i++) c.a[i]=a1.a[i]-a2.a[i]; for(R II i=1;i&lt;=c.a[0];i++) if(c.a[i]&lt;0) &#123; c.a[i]+=PI; c.a[i+1]--; &#125; while (!c.a[c.a[0]] &amp;&amp; c.a[0]!=1) c.a[0]--; return c; &#125; friend NU operator * (NU a1,NU a2) &#123; R NU c; R II w; for(R II i=1;i&lt;=a1.a[0];i++) for(R II j=1;j&lt;=a2.a[0];j++) &#123; w=c.a[i+j-1]+1ll*a1.a[i]*a2.a[j]; c.a[i+j]+=w/PI; c.a[i+j-1]=w%PI; &#125; for(R II i=1;i&lt;=a1.a[0]+a2.a[0];i++) &#123; if(c.a[i]) c.a[0]=i; c.a[i+1]+=c.a[i]/PI; c.a[i]%=PI; &#125; return c; &#125; IL void out() &#123; R II wei=a[0]; printf("%1d",a[wei--]); while (wei) printf("%1d",a[wei--]); puts(""); &#125;&#125; a, b, c;int main()&#123; a.in(); b.in(); c=a+b; c.out(); c=a-b; c.out(); // 一般这里a 是大于b 的 c=a*b; c.out(); exit(0);&#125; FHQ TreapBlog Tire and AC自动机Blog 树的重心Blog 点分治Blog gcd&amp;exgcdBlog 线性筛Blog 网络流12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define II int#define IL inline#define R register#define I 123546using namespace std;template &lt; typename T &gt; IL void of (R T &amp;a) &#123; R char c=getchar (); R T w=1, p=0; while (!isdigit(c)) &#123; if(c=='-') w=-1; c=getchar (); &#125; while (isdigit(c)) &#123; p=p*10+c-'0'; c=getchar (); &#125; a=w*p;&#125;/* -------------------- Peipei -------------------- */II tot=1,n,m,s,t,ans,Inf=1e8;II head[I], inq[I], bit[I];queue &lt;II&gt; Q;struct UUI &#123; II to,up,flow; &#125; aa[I];IL void join(R II x,R II y,R II z) &#123; aa[++tot]=(UUI) &#123;y,head[x],z&#125;; head[x]=tot; aa[++tot]=(UUI) &#123;x,head[y],0&#125;; head[y]=tot;&#125;IL bool bfs() &#123; for(R II i=1;i&lt;=n&lt;&lt;1;i++) inq[i]=0; Q.push(s); inq[s]=1; while (!Q.empty()) &#123; R II x=Q.front(); Q.pop(); for(R II i=head[x],go;i;i=aa[i].up) &#123; go=aa[i].to; if(!inq[go] &amp;&amp; aa[i].flow) &#123; inq[go]=inq[x]+1; Q.push(go); &#125; &#125; &#125; return inq[t];&#125;IL II dfs(R II x,R II a) &#123; if(x==t || !a) return a; R II now_f=0,f; for(R II &amp;i=bit[x],go;i;i=aa[i].up) &#123; go=aa[i].to; if(inq[go]==inq[x]+1 &amp;&amp; (f=dfs(go,min(aa[i].flow,a)))&gt;0) &#123; aa[i].flow-=f; aa[i^1].flow+=f; a-=f; now_f+=f; if(!a) return now_f; &#125; &#125; return now_f;&#125;int main()&#123; //freopen("1.in","r",stdin); of(n); of(m); of(s); of(t); s+=n; for(R II i=1;i&lt;=n;i++) join(i,i+n,1); for(R II i=1,x,y;i&lt;=m;i++) &#123; of(x); of(y); join(x+n,y,Inf); join(y+n,x,Inf); &#125; while (bfs()) &#123; for(R II i=1;i&lt;=n&lt;&lt;1;i++) bit[i]=head[i]; ans+=dfs(s,Inf); &#125; printf("%d\n",ans); exit(0);&#125;]]></content>
      <tags>
        <tag>algorithm of OI</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FHQ Treap]]></title>
    <url>%2F2018%2F04%2F22%2FFHQ%20Treap%2F</url>
    <content type="text"><![CDATA[FHQ Treap万岁，摒弃Splay ennnnnnnnn 说一说FHQ Treap，为什么这么推崇FHQ呢？？ 只会FHQ Splay极其容易被卡成 $dog$ 但是很少听到FHQ被卡 FHQ支持持久化，但是Splay不行 所以推荐FHQ 还有下文里的平衡树的性质 可以理解为一个节点的左子树所有权值都是小于当前节点权值的，右子树的所有权值都是大于当前节点权值的 这是个目录[TOC] 简介首先FHQ是一种平衡树，而且是一种Treap的延伸物[^我是这么想的] ，然后首先你可以先学Treap，然后再来看这篇，这样子可能学起来就简单一些了，然后就会忘记Treap怎么码，只会FHQ了，反正我现在码Treap是要现推的 FHQ Treap 又叫 非旋Treap 顾名思义，就是不旋转的Treap，总体来讲，会把Treap拆成一条条的链/子树，通过各种分离和拼接，来完成维护平衡树的工作 至于怎么拆成链/子树，可以看这个图 红线就是拆成的一条条的链 节点信息 $ls,rs$ 左右子树标号 $ra$ 优先级(rand()) $w$ 该节点权值 $siz$ 该子树大小 。。。。。一些题里要求的 基本函数split基本定义分离的意思，就是把一颗Treap以一种条件分离成两棵Treap，新的Treap是可以为空的，我们这里以权值为例，那么 $split$ 就可以是按照大于 w ，小于等于 w 来分离成两棵Treap：$l$ 和 $r$ 同时，根据定义我们有： $l$ 中的每一个节点的权值都小于等于 $w$ $r$ 中的每一个节点的权值都大于 $w$ code：123456789101112IL void split(int x,int &amp;l,int &amp;r,int w) &#123; if(!x) &#123; l=r=0; return ; &#125; if(Tr[x].w&lt;=w) &#123; l=x; // 这里必须先赋值 split(Tr[x].r,Tr[l].r,r,w); up(l); &#125; else &#123; r=x; split(Tr[x].l,l,Tr[r].l,w); up(r); &#125;&#125; 我尽量写的能看懂了 code解释由于平衡树的性质，如果当前节点的 $w_x$ 是小于等于我的分离接线 $w$ 点的话，那么当前节点的左子树任何一个权值 $w_l$ 都是小于 $w$ 的，那么我们就把当前节点以及左子树全部给 $l$ ，就像这张图 这时候就可以发现我们当前节点的右子树是还没有确定的，因为这里面可能大于小于 $w$ 的节点都可能存在，我不画图了，自己考虑平衡树，然后我们现在要去考虑右子树，所以我们传入了 $Tr[x].r$ 然后我们发现现在的 $l$ 的右子树是空的，所以如果之后向 $l$ 中加东西的话，就往右子树上加就好了，这里解释下有这样一些条件使得我们要往右子树加，而不是左子树 右子树是空的 我们之后处理的是当前节点的右子树，里面的任何一个权值都大于当前节点的权值，所以根据平衡树的性质，我们之后的点要放到右子树中 这样就差不多了，至于右子树，自行参考左子树 还有就是传址 因为我们要修改一些儿子的编号，这样传址就可以直接在 $l=x$ 或者 $r=x$ 时直接修改了 merge基本定义这个是合并，就是把两个Treap合并成一个 有分离就肯定有合并。。。。。 我们首先保证一个前提 $l$ 的所有节点权值都是$&gt;=r$ 的权值的 code：12345678910IL int merge(R II l,R II r) &#123; if(l*r==0) return l+r; if(Tr[l].ra&gt;Tr[r].ra) &#123; Tr[l].r=merge(Tr[l].r,r); up(l); return l; &#125; else &#123; Tr[r].l=merge(l,Tr[r].r); up(r); return r; &#125;&#125; code解释我们先有一张图： 如果当前 $l$ 节点的优先级 $&gt;$ 当前 $r$ 节点优先级，那么我们就把 $r$ 放到 $l$ 的右子树中，这样我们保证了平衡树的性质，但是如果 $l$ 有右子树怎么办。。。。。。。 这就化为了一个子问题，我们把 $r$ 和 $l$ 的右子树合并成一个Treap，然后作为 $l$ 的新右子树就OK了 所以我们下传的是 $merge(Tr[l].r,r)$ 这个比较简单，至于右子树，自行参考左子树 int main12345678910111213141516171819struct Tree &#123; II l,r,w,siz,ra; &#125; Tr[I];int main()&#123; srand(time(0)); // 合并 of(n); for(R II i=1;i&lt;=n;i++) &#123; int x; of(x); Tr[i]=(Tree) &#123;0,0,x,1,rand()&#125;; root=merge(root,i); &#125; // 分离 int l,r,w; of(w); split(root,l,r,w);&#125; $root$ 就是当前的整棵Treap的根节点编号 $l$ 和 $r$ 就是分离出来的两棵Treap的根节点编号 一些注意 我们在进行 $merge$ 和 $split$ 时，每次操作时，我们都保证了函数里左子树永远是 $l$ 右子树永远是 $r$ 这样我们才能保证平衡树的性质 注意每个函数的 $return$ 条件 EX函数去看例题好了。。。。。。。。。。。 updata6.27：找到了一道FHQ Treap可以水过的题：problem1 END]]></content>
      <tags>
        <tag>algorithm of OI</tag>
        <tag>FHQ Treap</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tire and AC自动机]]></title>
    <url>%2F2018%2F04%2F18%2FTire%20and%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[[TOC] 写在前面 Trie 是一个前置知识，所以我就从网上找了些介绍，然后借(Ctrl+C)鉴(Ctrl+V)过来了，所以要是有些神乎其神的地方我要是解释不了，大家可以自行百度 QAQ 然后是 AC自动机 这个是这篇 blog 主要讲的东西，但是我觉得对于这种字符串的东西，还是口胡的地方比较多，所以有关 AC自动机 的篇幅也不会太长，主要是在黑板上画来画去 然后我们就开始了 Trie or 字典树字典树的概念 字典树，因为它的搜索快捷的特性被单词搜索系统使用，故又称单词查找树。它是一种树形结构的数据结构。之所以快速，是因为它用空间代替了速度。 那什么是Trie？？！ 其实就是把一些字符串连到一个根节点上，既然有根节点了，那一定有了一颗树，那么，我们把这些串形成的树叫作 Trie； 字典树有三个基本性质： 根节点不包含字符，除根节点外每一个节点都只包含一个字符 从根节点到某一个节点，路径上经过的字符连接起来，就是该节点对应的字符串 每个节点的所有子节点包含的字符都不相同。 But why？？！because 这是基本性质代码 code ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define II int#define IL inline#define R register#define I 123456using namespace std;template &lt; typename T &gt; IL void of (R T &amp;a) &#123; R char c=getchar (); R T w=1, p=0; while (!isdigit(c)) &#123; if(c=='-') w=-1; c=getchar (); &#125; while (isdigit(c)) &#123; p=p*10+c-'0'; c=getchar (); &#125; a=w*p;&#125;/* -------------------- Peipei -------------------- */II n,Q,len,tot,root;II a[I];struct POI &#123; II up[10]; II is; &#125; Tr[I];IL II npoi() &#123; tot++; for(R II i=0;i&lt;=9;i++) Tr[tot].up[i]=0; Tr[tot].is=0; return tot;&#125;IL void in() &#123; of(len); for(R II i=1;i&lt;=len;i++) scanf("%1d",&amp;a[i]);&#125;IL void join() &#123; R II pi=root; for(R II i=1;i&lt;=len;i++) &#123; if(!Tr[pi].up[a[i]]) Tr[pi].up[a[i]]=npoi(); pi=Tr[pi].up[a[i]]; &#125; Tr[pi].is=1;&#125;IL bool ask() &#123; R II pi=root; for(R II i=1;i&lt;=len;i++) &#123; if(!Tr[pi].up[a[i]]) return 0; pi=Tr[pi].up[a[i]]; &#125; return Tr[pi].is;&#125;int main()&#123; of(n); for(R II i=1;i&lt;=n;i++) in(), join(); of(Q); while ( Q -- ) &#123; in(); ask() ? puts("Y") : puts("N") ; &#125; exit(0);&#125; 看不懂我的代码？？！ 我并没有办法。。。。。。。。。。。。。。 接下来是网上的的介绍，我就Ctrl+C+V过来了，我也没怎么看，ennnnnnnnn 大概是些定义，可以了解下 优点 可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。跟哈希表比较： 最坏情况时间复杂度比hash表好 没有冲突，除非一个key对应多个值（除key外的其他信息） 自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。 缺点 虽然不同单词共享前缀，但其实trie是一个以空间换时间的算法。其每一个字符都可能包含至多字符集大小数目的指针（不包含卫星数据）。 每个结点的子树的根节点的组织方式有几种。 果默认包含所有字符集，则查找速度快但浪费空间（特别是靠近树底部叶子）。 如果用链接法(如左儿子右兄弟)，则节省空间但查找需顺序（部分）遍历链表。 alphabet reduction: 减少字符宽度以减少字母集个数。, 对字符集使用bitmap，再配合链接法。 如果数据存储在外部存储器等较慢位置，Trie会较hash速度慢（hash访问O(1)次外存，Trie访问O(树高)）。 长的浮点数等会让链变得很长。可用bitwise trie改进。 然后 Trie 我们就讲到这里 AC自动机伪·自动AC机 nice 简介了解在学一个东西之前，我们要先了解这个东西是用来干什么的，所以呢，我现在要先说出一个最模糊的概念，也是最容易忽略的： AC自动机是处理字符串的有力工具 然后我们再继续了解下它的其他概念； 其他 AC自动机 Aho-Corasick automation，该算法在1975年产生于贝尔实验室，是著名的多模匹配算法之一。 常见例子 给出n个单词，再给出一段包含m个字符的文章，让你找出有多少个单词在文章里出现过。 学习前提 要搞懂AC自动机，先得有字典树Trie和KMP模式匹配算法的基础知识。 与KMP区分 KMP算法是单模式串的字符匹配算法，AC自动机是多模式串的字符匹配算法。 大致思路三步走 Trie树 Fail指针 匹配 Trie 我们之前讲了，所以呢，我们已经走了第一步，【开心】那么我们还有两步要走，那么当然是接着走了。。。。 思想实现我要做什么？？！ 这是一个值得思考的问题，只有我们知道了要干什么我们才能去实现； 就像刚刚简介里的经典问题：给出n个单词，再给出一段包含m个字符的文章，让你找出有多少个单词在文章里出现过。 那么我们通过解决这个子问题来解决我们要干什么这个大问题； 那么大家先把自己想到的做法说一下 ​ ​ ​ ​ ​ ​ ​ ​ 然后我说一下我想说的 各种做法1.暴力 首先这是个极其不错的方法，至少错误率会比较低，而且好写，再而且，这是骗分的手段之一； 然后我们考虑实现 显然枚举每个单词，然后在文章里挨个匹配 code： 1234567891011for(R II i=1;i&lt;=n;i++)&#123; R II len1=strlen(s[i]+1); for(R II j=1;j&lt;=len;j++) &#123; for(R II k=1;k&lt;=len1;k++) if(S[j+k-1]!=s[k]) break ; else if(k==len1) ans++; &#125;&#125;printf("%d\n",ans); 复杂度：$O(n^3)$ 2.KMP优化 首先这是个不错的优化手段，因为KMP可以把匹配的过程由 $O(n^2)$ 优化到 $O(n)$ 然后我们考虑实现 显然枚举每个单词，先建立该单词的next，然后在文章里挨个匹配 code： 复杂度：$O(n^2)$ 3.AC自动机优化 首先名字都变长了，那肯定变 nb 了啊， Ta把我们用 KMP 优化后的东西又优化了，妈诶，太强了 然后我们考虑实现 显然，不，一点都不显然，不然我还讲个啥啊！！！ 考虑实现：比较重要，详细介绍下 每个新事物的开始都是异想天开 我们之前是一个个的单词去匹配，那我们能不能把所有的单词放在一起，然后一起匹配咧？？！ 肯定是可以的啊，我们把文章放在外层循环，然后当前位置去匹配所有的单词就可以了啊 额，上一个好像没什么用 那可咋办啊？？！ 但是我们已经把单词集中到一起了啊 我们发现，如果当前有 k 个单词可以在当前位置匹配上，那这 k 个单词一定有一个公共的前缀，所以嘞，有没有想到 Trie ( • ̀ω•́ )✧ 没想到也要想到。。。。 如果上述 k 个单词放到了 Trie 里，然后我们把当前位置(这个位置是上一个枚举到的位置)在 Trie 中匹配，是不是就直接可以一次匹配多个串了？？ ＼＼\٩(‘ω’)و//／／ 这样我们就可以把多个单词放到一起考虑了，太棒了 但是那些和这 k 个不一样的呢 就不要了呗，反正我们在 Trie 上也匹配不到这几个不一样的串 A：有用吗？ B：没用。。。 A：扔！！！ code实现Build_fail我们第二步是建立fail指针，所以我们需要了解fail具体是干什么的； 插播一段 fail 类似KMP中的next 令当前节点 A 的 fail 所指向的是节点 B ，则有 B 是A的后缀【解释】 这个 fail 就是AC自动机的优化之处 因为它和 KMP 的 next 数组一样，可以跳转到至少不会更差的地方 为什么不会更差？？！ 我们保证了当前节点 A 的 fail 指针所指向的节点 B ，以 B 为结尾的单词串一定是以 A 为结尾的单词的后缀；至于原因，自行KMP 解释结束 不懂快问，不然就继续了 over 然后我们去考虑如何实现； 我们知道一个显然的事情：一个字符串的后缀一定比该字符串短； 再根据前面说的 fail 所指向的含义； 可知，当前节点 A 的 fail 的深度一定比 A 小； 然后，根据 KMP 的 next 的求法：当前点 A 的 next 由 A 的前一个点 B 的 next 推出； 那我们放到 Trie 上，当前节点 A 的前一个节点就是 A 的父亲，所以我们 A 的 fail 是由它的父亲推出，同理，这颗 Trie 上的任何一个节点都满足这个性质；（如下图） 那么我们就可以用一种数据结构来处理： queue 每一层的构建方式都类比上一层 理解或者没理解，我现在在图上模拟一下建立 fail 的过程 (复制到画板上。。。。。。。。。。。。。) code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;#define II int#define R register#define I 1623456using namespace std;struct node &#123; II up[27]; II is, fail;&#125;Tr[I];II _tot=-1,root,n,len,ans;char a[I];II new_one() &#123; _tot++; for(R II i=1;i&lt;=27;i++) Tr[_tot].up[i]=0; Tr[_tot].is=0; Tr[_tot].fail=0; return _tot;&#125;void fffail()&#123; queue &lt;II&gt; Q; for(R II i=1;i&lt;=26;i++) &#123; if(Tr[root].up[i]) &#123; Tr[Tr[root].up[i]].fail=root; Q.push(Tr[root].up[i]); &#125; else Tr[root].up[i]=root; &#125; while (not Q.empty()) &#123; R II pi=Q.front(); Q.pop(); for(R II i=1;i&lt;=26;i++) &#123; R II go=Tr[pi].fail; R II son=Tr[pi].up[i]; if(Tr[pi].up[i]) &#123; while (not Tr[go].up[i] and go) &#123; go=Tr[go].fail; &#125; if(not Tr[go].up[i]) Tr[son].fail=root; else Tr[son].fail=Tr[go].up[i]; Q.push(son); &#125; else &#123; Tr[son].up[i]=Tr[Tr[pi].fail].up[i]; &#125; &#125; &#125;&#125;int main()&#123; root=new_one(); scanf("%d",&amp;n); for(R II i=1;i&lt;=n;i++) &#123; scanf("%s",a+1); len=strlen(a+1); R II pi=root; for(R II j=1;j&lt;=len;j++) &#123; R II o=a[j]-'a'+1; if(not Tr[pi].up[o]) Tr[pi].up[o]=new_one(); pi=Tr[pi].up[o]; &#125; Tr[pi].is++; &#125; fffail(); scanf("%s",a+1); len=strlen(a+1); R II pi=root; for(R II i=1;i&lt;=len;i++) &#123; R II o=a[i]-'a'+1; R II pr=pi; while (not Tr[pi].up[o] and pi) pi=Tr[pi].fail; pi=Tr[pi].up[o]; if(not pi) pi=root; while (pr and Tr[pr].is&gt;=0) &#123; ans+=Tr[pr].is; Tr[pr].is=-1; pr=Tr[pr].fail; &#125; &#125; printf("%d\n",ans); exit(0);&#125; 几十年前的代码了，勿喷。。。。。。。。。。。。。。。 简单应用简单应用在OI里当然是做题了。。。。。。。。。。。。。。 T1 luogu AC自动机(简单版)and(加强版) T2 HDU 3341 Lost’s revenge T3 HDU 2896 病毒侵袭 T4 并没有T4，略略略，以上的T1理解，T2，T3。。。。算了 solution T1 裸的AC自动机（都模板了好不，刚讲的） T2 。。。。。。。。。。。。 T3 。。。。。。。。。。。。。。 END当然有PPT的]]></content>
      <tags>
        <tag>algorithm of OI</tag>
        <tag>Tire</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu P1169 [ZJOI2007]棋盘制作]]></title>
    <url>%2F2018%2F04%2F15%2Fluogu%20P1169%20%5BZJOI2007%5D%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[这个题是悬线法的练习题，十分 nice，我第一次做的时候，十分尬，问的白学家，写了好久，然后才过，刚刚写了下，还OK吧，1A 写一下这个题的思路 给定一个 01 矩阵，找一个最大的正方形矩阵，和一个长方形矩阵，要求这两个矩阵的 01 是相见分布的就像样例里的这个图，正方形就是红圈这个矩阵 至于为什么用悬线法，我们考虑一个合法的 01 矩阵，我们可以选择其中的任意列作为我们所找的线，然后这条线上的任何一个点的 $l[i][j]$ 和 $r[i][j]$ 的最小值就是这个矩阵的长，即 $$l_{矩阵}=min\{l[i][j]\} (i,j)∈所选线$$ $$r_{矩阵}=min\{r[i][j]\} (i,j)∈所选线$$ 设我们选的线是褐色格子，那么 $l_{矩阵}$ 就是最左侧的那一列，没有 $r_{矩阵}$ 然后我们就可以用悬线法来处理 $l[i][j], r[i][j]$ 然后 $for$ 就OK了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define II int#define IL inline#define R register#define I 2010using namespace std;template &lt; typename T &gt; IL void of (R T &amp;a) &#123; R char c=getchar (); R T w=1, p=0; while (!isdigit(c)) &#123; if(c=='-') w=-1; c=getchar (); &#125; while (isdigit(c)) &#123; p=p*10+c-'0'; c=getchar (); &#125; a=w*p;&#125;template &lt; typename T &gt; IL void Big (R T &amp;a,R T b) &#123; a&lt;b?a=b:0; &#125;template &lt; typename T &gt; IL void Sma (R T &amp;a,R T b) &#123; a&gt;b?a=b:0; &#125;template &lt; typename T &gt; IL void Swap(R T &amp;a,R T &amp;b) &#123; R T c=b;b=a;a=c; &#125;/* -------------------- Peipei -------------------- */II n,m,ans1,ans2; II a[I][I], l[I][I], r[I][I];int main()&#123; //freopen("1.in","r",stdin); of(n); of(m); for(R II i=1;i&lt;=n;i++) for(R II j=1;j&lt;=m;j++) of(a[i][j]); for(R II i=1;i&lt;=n;i++) for(R II j=2;j&lt;=m;j++) if(a[i][j]==(a[i][j-1]^1)) l[i][j]=l[i][j-1]+1; for(R II i=1;i&lt;=n;i++) for(R II j=m-1;j;j--) if(a[i][j]==(a[i][j+1]^1)) r[i][j]=r[i][j+1]+1; for(R II j=1,len=1,ll,rr;j&lt;=m;j++) &#123; len=1, ll=l[1][j], rr=r[1][j]; Big(ans1,min(len,ll+rr+1)*min(len,ll+rr+1)); Big(ans2,len*(ll+rr+1)); for(R II i=2;i&lt;=n;i++) &#123; if(a[i][j]==(a[i-1][j]^1)) &#123; len++; Sma(ll,l[i][j]); Sma(rr,r[i][j]); &#125; else &#123; len=1; ll=l[i][j]; rr=r[i][j]; &#125; Big(ans1,min(len,ll+rr+1)*min(len,ll+rr+1)); Big(ans2,len*(ll+rr+1)); &#125; &#125; printf("%d\n%d\n",ans1,ans2); exit(0);&#125;]]></content>
      <tags>
        <tag>problem of OI</tag>
        <tag>luogu</tag>
        <tag>solution</tag>
        <tag>悬线法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悬线法]]></title>
    <url>%2F2018%2F04%2F15%2F%E6%82%AC%E7%BA%BF%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Q：是什么呢？ A：就是很nb的东西； Q：干什么的呢？ A：就是用来求最优矩阵的； 首先我们有一个矩阵，然后我们需要一个最优矩阵；我一般能想到的就是n^3暴力前缀和，昨天还写了个注意事项呢；但是，今天就被怼死了； 那么我们就要学一下悬线法了； 顾名思义，就是悬好多线，然后左右扩展，得到最优矩阵； O(nm)；然后呢，我们先要找悬线；枚举每一行/列，令当前点 $a[i][j]$；令o为只是该行状态下的 $a[i][j]$ 能扩展的最远距离; 1234567if a[i][j] and a[i-1][j] -&gt; can make a team; go; then l[i][j]=min(l[i][j],o); else go again; then l[i][j]=o, h[i][j]=new line;end; 就是说，我们一个点可以顺接左侧的点，那么我这个点的左侧最远合法距离=左侧的点左侧最远合法距离+1 否则就是当前一个点，即 =1 然后就好了；$r[i][j]$ 的方式和这个一样；所以就每次都跟新下答案； 至于例题可以看这个 Q：还是不太懂。。。。。。。 A：gun~]]></content>
      <tags>
        <tag>algorithm of OI</tag>
        <tag>悬线法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的重心]]></title>
    <url>%2F2018%2F04%2F10%2F%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%2F</url>
    <content type="text"><![CDATA[我们先介绍一棵树的重心的概念： 以所有节点为根，重心的最大子树最小， 最大子树指子树节点数最多 然后我们就可以用一个所谓的树形DP解决这个事情 就是我们先随便找一个 $root$ 然后 dfs(root) 每到一个点，计算其最大子树，然后比较，挑选出最大子树最小的那个节点，所有节点处理完后，就找到了重心 至于一个节点怎么算他的最大子树 在 dfs 中该节点的子树不用多说，但是，这并不是全部，我们现在要求得是，以当前节点为根的最大子树，那么这个节点还有一个子树就是他的父亲，请自行画图 123456789101112IL void get_root(R II x,R II fat) &#123; siz[x]=1; W[x]=0; for(R II i=head[x],go;i;i=aa[i].up) &#123; if(inq[go=aa[i].to] || go==fat) continue ; get_root(go,x); Big(W[x],siz[go]); siz[x]+=siz[go]; &#125; Big(W[x],SIZ-siz[x]); if(W[x]&lt;W[root]) root=x;&#125; 而他父亲作为子树时的大小就是所有节点减去当前节点所代表的的子树大小。。。。。。。。。 emmmmmmmmmmmmmmm 还是自行画图]]></content>
      <tags>
        <tag>algorithm of OI</tag>
        <tag>DP</tag>
        <tag>树的重心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治]]></title>
    <url>%2F2018%2F04%2F10%2F%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[这个知识点我就写过两道题，一个模板，一个聪聪可可 然后呢，我现在要写一下我对这个题的理解 首先呢，这个算法是用来解决一些树上路径问题的，我做的这两道题都是关于树上路径长度统计的 我们先有一颗树，然后树边上有边权 比如这棵树，我们要查询长度为 $6$ 的路径条数，然后我们选取一个节点，接下来我们遍历这个节点的子树，然后记录当前节点到达每个子树中每个节点的路径长度，最后分别组合，即为所有两端在当前节点的子树中的路径的所有情况 所以我们有个方法就是枚举每个点，然后去搞，但是显然，点的选择会影响最后的复杂度，比如一条链，如果每次都选顶端，那么就是 $O(n^2)$ 但是如果每次都选中间，就是 $O(nlogn)$， 可以自行画图理解下 我们处理完当前节点后，会处理该节点的所有子树，而且处理子树的时候所需要的点就是该子树，不会受到别的子树的影响，因为所有跨子树的情况我们都已经在当前节点处理好了，这样子我们处理子树的复杂度就和子树大小有关了 然后我们可以看出，如果当前节点的最大子树越小，最后的复杂度就越低，那么我们就会去想一下重心[^至于不会重心的同学，请在文末查看]，然后我们找到重心之后，会去计算路径，再然后，我们会去处理这个重心的子树，处理这个子树的方式同理，找到这颗子树的重心，然后像刚刚一样处理，不过在处理某一个子树的重心时，我们会用现在所处理树的 $size$ 进行处理，就是比如上面的图，处理 $3$ 这个子树时，大小是 $3$ 至于代码，可以参考另一篇blog：luogu P2634 [国家集训队]聪聪可可 重心学习]]></content>
      <tags>
        <tag>algorithm of OI</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu P2634 [国家集训队]聪聪可可]]></title>
    <url>%2F2018%2F04%2F10%2Fluogu%20P2634%20%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[这个题呢，就是点分治，因为首先题面可以解释为求有多少条路径长度是 3 的倍数，同一个点长度为 0，不同点算两次 然后就点分治好了，这个题总体来讲是比较裸的，毕竟我这种只去年写过一次点分治的模板题得蒟蒻都看出来了。。。。。。。。。 然后边长 $mod 3$ 存起来就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;#define II int#define IL inline#define R register#define I 41000using namespace std;template &lt; typename T &gt; IL void of (R T &amp;a) &#123; R char c=getchar (); R T w=1, p=0; while (!isdigit(c)) &#123; if(c=='-') w=-1; c=getchar (); &#125; while (isdigit(c)) &#123; p=p*10+c-'0'; c=getchar (); &#125; a=w*p;&#125;template &lt; typename T &gt; IL void Big (R T &amp;a,R T b) &#123; a&lt;b?a=b:0; &#125;template &lt; typename T &gt; IL void Sma (R T &amp;a,R T b) &#123; a&gt;b?a=b:0; &#125;/* -------------------- Peipei -------------------- */II _tot,n,all,root,Inf=1e9,PI=3,SIZ;II head[I], W[I], inq[I], siz[I], kc[4], nu[4], ck[4];struct UI &#123; II to,up,w; &#125; aa[I];IL void join(R II x,R II y,R II z) &#123; aa[++_tot]=(UI) &#123;y,head[x],z&#125;; head[x]=_tot; aa[++_tot]=(UI) &#123;x,head[y],z&#125;; head[y]=_tot;&#125;IL void Q_SIZ(R II x,R II fat) &#123; SIZ++; for(R II i=head[x],go;i;i=aa[i].up) &#123; if(inq[go=aa[i].to] || go==fat) continue ; Q_SIZ(go,x); &#125;&#125;IL void get_root(R II x,R II fat) &#123; siz[x]=1; W[x]=0; for(R II i=head[x],go;i;i=aa[i].up) &#123; if(inq[go=aa[i].to] || go==fat) continue ; get_root(go,x); Big(W[x],siz[go]); siz[x]+=siz[go]; &#125; Big(W[x],SIZ-siz[x]); if(W[x]&lt;W[root]) root=x;&#125;IL void ROOT(R II x) &#123; SIZ=0; Q_SIZ(x,0); root=0; get_root(x,0); &#125;IL II gcd(R II a,R II b,R II c=0) &#123; while (b) &#123; c=b;b=a%b;a=c; &#125; return a; &#125;IL void get_dep(R II x,R II fat,R II len) &#123; kc[len]++; for(R II i=head[x],go;i;i=aa[i].up) &#123; if(inq[go=aa[i].to] || go==fat) continue ; get_dep(go,x,(len+aa[i].w)%PI); &#125;&#125;IL void ADD(R II x=0,R II y=0,R II z=0) &#123; x=ck[0]*kc[0]+ck[1]*kc[2]+ck[2]*kc[1]; y=ck[0]*kc[1]+ck[1]*kc[0]+ck[2]*kc[2]; z=ck[0]*kc[2]+ck[1]*kc[1]+ck[2]*kc[0]; ck[0]+=kc[0]; kc[0]=0; nu[0]+=x; ck[1]+=kc[1]; kc[1]=0; nu[1]+=y; ck[2]+=kc[2]; kc[2]=0; nu[2]+=z;&#125;IL void get_ans(R II x) &#123; ck[0]=1; ck[1]=ck[2]=0; for(R II i=head[x],go;i;i=aa[i].up) &#123; if(inq[go=aa[i].to]) continue ; get_dep(go,x,aa[i].w); ADD(); &#125;&#125;IL void solve(R II x) &#123; inq[x]=1; get_ans(x); for(R II i=head[x],go;i;i=aa[i].up) &#123; if(inq[go=aa[i].to]) continue ; ROOT(go); solve(root); &#125;&#125;int main()&#123; of(n); for(R II i=1,x,y,z;i&lt;n;i++) &#123; of(x); of(y); of(z); z%=PI; join(x,y,z); &#125; W[0]=Inf; ROOT(1); solve(root); nu[0]=nu[0]*2+n; printf("%d/%d\n",nu[0]/gcd(nu[0],n*n),n*n/gcd(nu[0],n*n)); exit(0);&#125;]]></content>
      <tags>
        <tag>problem of OI</tag>
        <tag>点分治</tag>
        <tag>luogu</tag>
        <tag>solution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu P1941 飞扬的小鸟]]></title>
    <url>%2F2018%2F04%2F09%2Fluogu%20P1941%20%E9%A3%9E%E6%89%AC%E7%9A%84%E5%B0%8F%E9%B8%9F%2F</url>
    <content type="text"><![CDATA[这个题，一眼傻逼 DP， 状态： ​ $f[i][j]$ 代表到达第 $i$ 行第 $j$ 列的最少点击数 有转移方程： ​ $$f[i][j] = min\{f[i-1][j-up[i-1]*k]+k,f[i-1][j+dow[i-1]]\}$$ 因为首先我们可以从前一行的格子向上跳 up[i-1] 格，使之到达当前行，由于向上跳没有限制[^坑点1]，所以要乘 $k$ ，而同样可以向下跳 dow[i-1] 格到达当前行，但是只能跳一次，不需要乘 比如这个图 我们当前第 $i$ 行的褐色格子，可以由 $i-1$ 行的 $j+dow[i-1]$ 黄色格子下降 $dow[i-1]$ 格到达，也可以由 $j-up[i-1]$ 的红色格子向上跳一次 $up[i-1]$ 格到达，也可以由 $j-up[i-1]2$ 的蓝色格子跳 $up[i-1]2$ 格到达 至于没有到达的情况，注意是输出穿越了几个柱子[^坑点2]，而不是通过了几列格子 所以就直接枚举转移就好了，我这里用的是滚动数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define II int#define IL inline#define R register#define I 10100using namespace std;template &lt; typename T &gt; IL void of (R T &amp;a) &#123; R char c=getchar (); R T w=1, p=0; while (!isdigit(c)) &#123; if(c=='-') w=-1; c=getchar (); &#125; while (isdigit(c)) &#123; p=p*10+c-'0'; c=getchar (); &#125; a=w*p;&#125;template &lt; typename T &gt; IL void Big (R T &amp;a,R T b) &#123; a&lt;b?a=b:0; &#125;template &lt; typename T &gt; IL void Sma (R T &amp;a,R T b) &#123; a&gt;b?a=b:0; &#125;/* -------------------- Peipei -------------------- */II n,m,k,ans=1e9,Inf=1e9;II f[I], g[I], dow[I], up[I], bot[I], top[I], is[I];int main()&#123; // freopen("1.in","r",stdin); of(n); of(m); of(k); for(R II i=1;i&lt;=n;i++) of(up[i]), of(dow[i]), top[i]=m+1; top[n+1]=m+1; for(R II i=1,x;i&lt;=k;i++) &#123; of(x); x++; is[x]=1; of(bot[x]); of(top[x]); &#125; for(R II i=1,flag;i&lt;=n;i++) &#123; is[i]+=is[i-1]; swap(f,g); for(R II j=1;j&lt;=m;j++) f[j]=Inf; for(R II j=bot[i]+1,to;j&lt;top[i];j++) &#123; to=j+up[i]; if(to&lt;top[i+1]) Sma(f[to],g[j]+1); &#125; for(R II j=m;j&gt;=m-up[i];j--) Sma(f[m],g[j]+1); for(R II j=up[i]+1;j&lt;=m;j++) Sma(f[j],f[j-up[i]]+1); for(R II j=m;j&gt;=m-up[i];j--) Sma(f[m],f[j]+1); for(R II j=bot[i]+1,to;j&lt;top[i];j++) &#123; to=j-dow[i]; if(to&gt;bot[i+1]) Sma(f[to],g[j]); &#125; for(R II j=1;j&lt;=bot[i+1];j++) f[j]=Inf; for(R II j=m;j&gt;=top[i+1];j--) f[j]=Inf; flag=0; for(R II j=bot[i+1]+1;j&lt;top[i+1];j++) if(f[j]&lt;Inf) &#123; flag=1; break ; &#125; if(!flag) &#123; printf("0\n%d\n",is[i]); exit(0); &#125; &#125; for(R II i=1;i&lt;=m;i++) Sma(ans,f[i]); printf("1\n%d\n",ans); exit(0);&#125;]]></content>
      <tags>
        <tag>problem of OI</tag>
        <tag>luogu</tag>
        <tag>solution</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[see this]]></title>
    <url>%2F2018%2F04%2F09%2Fsee%20this%2F</url>
    <content type="text"><![CDATA[12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; puts("Silence!!"); puts("Hello everyone,I am Peipei.");&#125;]]></content>
      <tags>
        <tag>mood</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算是分割线吧]]></title>
    <url>%2F2018%2F04%2F09%2F%E7%AE%97%E6%98%AF%E5%88%86%E5%89%B2%E7%BA%BF%E5%90%A7%2F</url>
    <content type="text"><![CDATA[ennnnnnnnnnn 接下来还是要 noip ，虽然尬，但是也没办法，然后这篇 blog 就是记录下我现在想说的，ennnnnnnnnnnnnn 首先我接下来的 blog 肯定大部分是算法介绍，题解，以及时不时地写一下自己想写的 然后当然要放下剩下的其他事情，还有文化课，eaaaaaaaaQAQ 过几天就 APIO 了，然而没有分到一个考区，十分尬 我的 blog 不能用百度搜到，mmp 好吧，没什么了，要做题了 奥对还有，今天省一们就算是退役了，都回家放假了，YY家太远，现在在机房 ennnnnnn，怎么讲呢，祝各位 AFO 开心吧]]></content>
      <tags>
        <tag>mood</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcd&exgcd]]></title>
    <url>%2F2018%2F04%2F08%2Fgcd%26exgcd%2F</url>
    <content type="text"><![CDATA[其实这个东西可以背板子的； 所以我打算直接上板子： gcd12345II gcd(R II a,R II b,R II c=0)&#123; while (b) &#123; c=b; b=a%b; a=c; &#125; return a;&#125; exgcd123456789101112R II x,y;void exgcd(R II x,R II y)&#123; if(!b) &#123; x=1; y=0; return ; &#125; exgcd(a%b,b); R II x2=x,y2=y; x=y2; y=x2-y2*(a/b);&#125; by pretend-fal END;]]></content>
      <tags>
        <tag>algorithm of OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性筛]]></title>
    <url>%2F2018%2F04%2F08%2F%E7%B4%A0%E6%95%B0%E7%AD%9B%2F</url>
    <content type="text"><![CDATA[好像有叫做线性素数筛的东西，而且我不知道我的是不是； 至于为怎么写这篇文章，其实就是背不过，然后以后复习用； 鉴于以上目的，我就直接上代码了，挺好背的，背过就好了； 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define II int#define R register#define I 2000000using namespace std;II n,_tot;II op[I], is[I];void sss()&#123; for(R II i=2;i&lt;=I-100;i++) &#123; if(!is[i]) op[++_tot]=i; for(R II j=1;j&lt;=_tot &amp;&amp; op[j]*i&lt;=I-100;j++) &#123; is[op[j]*i]=1; if(i%op[j]==0) break ; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); sss(); for(R II i=1;i&lt;=_tot;i++) if(op[i]&gt;=n&amp;&amp;(!is[i])) &#123; printf("%d\n",op[i]); exit(0); &#125;&#125; by pretend-fal END;]]></content>
      <tags>
        <tag>algorithm of OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈论]]></title>
    <url>%2F2018%2F04%2F08%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[一．巴什博奕（Bash Game）：首先我们来玩一个比较古老的报数游戏。A和B一起报数，每个人每次最少报一个,最多报4个。轮流报数,看谁先报到30.如果不知道巴什博弈的可能会觉得这个是个有运气成分的问题，但是如果知道的人一定知道怎样一定可以赢。比如A先报数的话,那么B一定可以赢(这里假定B知道怎么正确的报数)B可以这样报数,每次报5-k(A)个数,其中k(A)是A报数的个数这样的话没一次两人报完数之后会变成5 10 15 20 25 30这样是不是B一定会赢呢?是不是有一种被欺骗的感觉呢?好吧下面我们来看看这个原理。我们先看下一个一眼就能看出答案的例子 比如说我们报到5(4+1),每次报最多报4个,最少报1个.那么是不是后者一定可以赢呢？答案是肯定的。好了到这巴什博弈的精髓基本就OK了。那么如果我们要报到n+1,每次最多报n个,最少报1个的话,后者一定能够赢。现在我们需要报数到n,而每次最多报数m个,最少报数1个.我们可以化成这样n = k*(1+m)+r(0 &lt;= r &lt;= m）这样的话如果r不等于0那么先手一定会赢，为什么呢？首先先手报r个,那么剩下k倍(1+m)个数,那么我们每次报数1+m-k(B)个数就一定能保证最后剩下1+m个,那么就到了上面我们说的那个了,先手就一定会赢,如果r=0那么后手一定会赢,道理一样的。到这巴什博弈也就介绍完了,知道这个道理之后我们也可以去骗小朋友了。-_-//代码如下：123456789101112131415161718192021222324#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #define CLR(arr, val) memset(arr, val, sizeof(arr)) using namespace std; int main() &#123; //freopen("Input.txt", "r", stdin); int N, num, limit; scanf("%d", &amp;N); while(N--) &#123; scanf("%d%d", &amp;num, &amp;limit); if(num % (limit + 1) != 0) //必胜局面 printf("Win\n"); else printf("Lose\n"); &#125; return 0; &#125; ​ 二．威佐夫博奕（Wythoff Game）： 这种博弈比前面一种要稍微复杂一点。我们来看下下面这个游戏。 有两堆火柴棍,每次可以从某一堆取至少1根火柴棍(无上限)，或者从两堆取相同的火柴棍数。最后取完的是胜利者。好了,如果你不知道这个博弈定理,对于小数目的火柴棍数,可能还能推出来,但是如果火柴棍数一多,就不行了。看了下面的这个介绍,你也会有一种被骗的感觉。 首先我们知道两堆火柴是没有差别的,也就是说第一堆有a根,第二堆有b根和第一堆有b根,第二堆有a根是一样的结果。 我们用一个二维的状态（a,b)来记录当前剩下的火柴数，表示第一堆剩下a根火柴,第二堆剩下b根火柴。同样我们假设两个人的编号是A和B，且A先取。那么如果某个人遇到了这样的状态(0,0)那么也就是说这个人输了。这样的状态我们叫做奇异状态,也可以叫做失败态。那么接下来的几个失败态为(1,2),(3,5),(4,7),(6,10),(8,13)……我们用a[i]表示失败态中的第一个,b[i]表示失败态中的第二个.(i从0开始).那么我们可以看到b[i] = a[i]+i;（i &gt;= 0）,a[i]是前面的失败态中没有出现过的最小的整数下面我们可以得到三个基本的结论。 1.每个数仅包含在一个失败态中 首先我们知道a[k]是不可能和前面的失败态中的a[i],b[i]重复的(这点由a[i]的得到可以知道)b[k] = a[k]+k &gt; a[k-1]+k&gt;a[k-1]+k-1+1&gt;a[k-1]+(k-1) = b[k-1]&gt;a[k-1]这样我们知道每个数仅在一个失败态中。 2.每个失败态可以转到非失败态。 加入当前的失败态为(a,b)，那么如果我们只在一堆中取的话,肯定会变成非失败态(这点由第一点可以保证),如果从两堆同时取的话,由于每个失败态的差是不一样的,所以也不可能得到一个失败态。也就是说一个失败态不管你怎么取,都会得到一个非失败态。 3.每个非失败态都可以转到一个失败态对于这个结论,首先我们要知到每个状态(a,b)要么a = a[i],要么b = b[i].(每个数都出现在一个失败态中),下面我们分两种情况来讨论 I.a = a[i].如果b = a的话那么一次取完就变成了(0,0).如果b &gt; b[i]的话,那么我们从第二堆中取走b-b[i]就变成了一个失败态。如果b &lt; b[i].那么我们从两堆中同时取走a-a[b-a[i]]这样得到失败态(a[b-a[i]],a[b-a[i]]+b-a[i])(a[i] = a) II.b = b[i].如果a &gt; a[i]那么我们从第一堆中取走a-a[i]根火柴. 如果a &lt; a[i].这里又分两种情况。第一是a = ak那么我们从第二堆取走b - b[k]就行了。第二是a = b[k]这样的话由于两堆火柴是没有区别的,所以我们把b变成a[k]就行了,也即是从第二堆火柴中取走b - a[k]就变成了失败态至于怎么判断一个状态是否是失败态.我们可以用下面的方法来判断(本人暂时还不会证明) a[i] = i*(1+√5)/2 b[i] = a[i]+i; 那么这就是一个失败态代码如下：​1234567891011121314151617181920212223#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define CLR(arr, val) memset(arr, val, sizeof(arr)) using namespace std; int main() &#123; //freopen("Input.txt", "r", stdin); int num1, num2, tmp; //第一堆剩的数量为num1,第二堆剩num2 while(scanf("%d%d", &amp;num1, &amp;num2) != EOF) &#123; if(num1 &gt; num2) swap(num1, num2); tmp = floor((num2 - num1) * (1 + sqrt(5.0)) / 2.0); //黄金分割 if(tmp == num1) printf("Lose\n"); //奇异局势必败 else printf("Win\n"); &#125; return 0; &#125; 三．尼姆博奕（Nimm Game）： 指的是这样的一个博弈游戏，目前有任意堆石子，每堆石子个数也是任意的，双方轮流从中取出石子，规则如下：1)每一步应取走至少一枚石子；每一步只能从某一堆中取走部分或全部石子；2)如果谁取到最后一枚石子就胜。也就是尼姆博弈（Nimm Game）。必败局面：也叫奇异局势。无论做出何出操作，最终结果都是输的局面。必败局面经过2次操作后，可以达到另一个必败局面。必胜局面：经过1次操作后可以达到必败局面。即当前局面不是必败局面就是必胜局面，而必胜局面可以一步转变成必败局面。最终状态：（1）最后剩下一堆石子；（必胜局面）（2）剩下两堆，每堆一个；（必败局面）（3）当石子剩下两堆，其中一堆只剩下1颗，另一堆剩下多于n颗石子时，当前取的人只需将多于1颗的那一堆取出n-1颗，则局面变为刚才提到的必败局面。（必胜局面）判断当前局势是否为必胜（必败）局势：1）把所有堆的石子数目用二进制数表示出来，当全部这些数按位异或结果为0时当前局面为必败局面，否则为必胜局面；2）在必胜局面下，因为所有数按位异或的结果是大于零的，那么通过一次取，将这个（大于其它所有数按位异或的结果的）数下降到其它所有数按位异或的结果，这时局面就变为必败局面了。定理：一组自然数中必然存在一个数，它大于等于其它所有数按位异或的结果。证明：原命题等价于，设a1＾a2＾… ＾an=p，p≠0时，必存在k，使得ak＾p&lt;ak（当p=0时，对于任意的k，有ak＾p=ak）。设p的最高位是第q位，则至少存在一个k，使得ak的第q位也是1，而ak＾p的第q位为0，所以ak^p&lt;ak 补缀一点，（a＾b）＾b=a＾（b＾b）=a＾0=a，所以ak＾p相当于“其它所有数按位异或的结果”。例1：2 45 4545＾45＝0,45和45的异或等于0。例 2：3 3 6 9局势（3,6，9）因为3＾6＾9不等于0，所以这是一个必胜局势。 3 011＾6 110 5 101 即从第3堆中的9个中取走9－5＝4个，则（3,6，9）－＞（3,6，5），3＾6＾5＝0，故（3,6，5）为奇异局势，即从必胜局势转变成必败局势。代码如下：​123456789101112131415161718192021#include&lt;iostream&gt; using namespace std; int temp[ 20 ]; //火柴的堆数 int main() &#123; int i, n, min; while( cin &gt;&gt; n ) &#123; for( i = 0; i &lt; n; i++ ) cin &gt;&gt; temp[ i ]; //第i个火柴堆的数量 min = temp[ 0 ]; for( i = 1; i &lt; n ; i++ ) min = min^temp[ i ]; //按位异或 if( min == 0 ) cout &lt;&lt; "Lose" &lt;&lt; endl; //输 else cout &lt;&lt; "Win" &lt;&lt; endl; //赢 &#125; return 0; &#125;]]></content>
      <tags>
        <tag>algorithm of OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2018%2F04%2F08%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集，顾名思义，就是把元素并到一个集合里，然后还可以查找某个元素在哪一个集合里；** 这其实就是并查集了，思想很简单，而且很好写，不过很少会有题专门考并查集，但是，不可否认的是，并查集是一个极为有用的辅助算法，或者说是思想，再或者是一种实现方式； 并查集有几个主要操作： Ⅰ 初始化：我们会把每一个点放入一个单独的集合，即fa[x]=x，代表x所在的这个集合的代表元素是x； Ⅱ 查询：我们每一个集合的表现形式是一颗树，而所有的集合便表现为一个森林，所以我们递归地查询x所在的集合，一旦找到某一个点是一个集合的代表元素，那么我们就可以认为x与这个点在一个集合（而且一定在一个集合），并且这个集合是现在找到的这个点所代表的集合； Ⅲ 合并： 假设我们希望把元素A与元素B合并到一个集合中，那么我们可以将这两个点所在的集合的代表元素合并到一个集合，至于这个过程，详情见代码； 声明：本博客图片来自网络； 查询：1234567int find(int x) //查找我（x）的掌门&#123; int r=x; //委托 r 去找掌门 while (pre[r]!=r) //如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =） r=pre[r] ; // r 就接着找他的上级，直到找到掌门为止。 return r ; //掌门驾到~~~&#125; 合并： 123456void join(int x,int y) //我想让虚竹和周芷若做朋友&#123; int fx=find(x),fy=find(y); //虚竹的老大是玄慈，芷若MM的老大是灭绝 if(fx!=fy) //玄慈和灭绝显然不是同一个人 pre[fx]=fy; //方丈只好委委屈屈地当了师太的手下啦&#125; 还有一个路径压缩，比较重要，它一定程度上决定了并查集的效率； 所谓路径压缩，就是把原来是一个长链的树处理成一颗深度较浅的树，以至于查询时不至于递归太多次，其实就是一个小细节问题； 123456789II find (R II x)&#123; if(x==fa[x]) return x; else return fa[x]=find(fa[x]); //这个地方我们由 esle return find(fa[x]) 改为了 //return fa[x]=find(fa[x]); //就是每次查询，我们就会把没有并在代表元素上的节点并到代表元素上； //这样就可以使得树的深度较浅了；&#125; 效果大概就是这样的： 然后依旧是完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define II int#define IL inline#define R register#define I 123456using namespace std;IL void of(R II &amp;a) &#123; R char c=getchar (); R II w=1, p=0; while (c&lt;'0'||c&gt;'9') &#123; if(c=='-') w=-1; c=getchar (); &#125; while (c&gt;='0' &amp;&amp; c&lt;='9') &#123; p=p*10+c-'0'; c=getchar (); &#125; a=w*p;&#125;/* -------------------- Peipei -------------------- */II fa[I];II n,m;II find (R II x)&#123; if(x==fa[x]) return x; else return fa[x]=find(fa[x]); //这个地方我们由 esle return find(fa[x]) 改为了 //return fa[x]=find(fa[x]); //就是每次查询，我们就会把没有并在代表元素上的节点并到代表元素上； //这样就可以使得树的深度较浅了；&#125; void join(R II x,R II y) &#123; fa[x]=y; &#125;int main()&#123; of(n); of(m); for(R II i=1;i&lt;=n;i++) fa[i]=i; //初始化； for(R II i=1,x,y,z;i&lt;=m;i++) &#123; of(x); of(y); of(z); if(x==1) join(find(y),find(z)); //注意一定要传代表元素，保证正确性； //不明白可以画图试一下； else find(y)==find(z) ? printf("Y\n") : printf("N\n") ; //查询是否在一个集合中； &#125; return 0;&#125; by pretend-fal; END;]]></content>
      <tags>
        <tag>algorithm of OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarajn]]></title>
    <url>%2F2018%2F04%2F08%2FTarjan%2F</url>
    <content type="text"><![CDATA[Tarjan是多种算法的总称，因为Tarjan这个人太牛X了，那我们今天就来看一看Tarjan神的算法之一 ：Tarjan求割边割点； 首先我们要清晰什么是割边割点：​割点：​ 首先我们有一张连通图： ​ 对于这张图，显然它是一张联通图，那么割点的定义就是：“某一个点A，若删除这个点并且删去这个点所练的边，那么这张图的强联通分量增多”； 若删除点3及相连的边后，强联通分量就变成了{1,2}和{4,5,6} (点3已删除)； 那么割边呢？ 显然，根据割点的定义，割边的定义可以推得：“某一条边B，若删除该边，则所在图的强联通分量增多”；这个定义和割点的定义极其相似；​则，在上图中，若删除3—4这条边，改图的强联通分量数目改变，由{1,2,3,4,5,6}—&gt;{1,2,3}和{4,5,6}；所以，该图中3—4这条边就是该图的割边；​同样，一重点内容个图中的割点割边有时候不止一个；​​而Tarjan是怎么求割边割点呢？？！用一个dfs的思想，建一棵搜索树；然后我们有一个结论：​ 割点： 若这个点A是根节点，那么只要它有两棵及以上的子树，那么它必为割点；​ 若这个点A不是根节点，则如果它所有儿子的LOW都小于等于节点A的DFN，则节点A是割点；​​割边同样可以类比割点的性质；割边： 若该节点A，与它的子节点B，若节点B的LOW小于A的DFN，则A——B是割边；​割点： 证明：若该根节点A含有两棵及以上子树，则删去节点A，其子树必定成为独立的强联通分量，且数量增多；反之，若只含有一棵子树，则节点A删除后对原图联通性毫无影响； 证明：若节点A非根节点，且没有一个儿子的LOW小于A的DFN，即没有回边指向节点A的祖先，所以以节点A为根的子树是通过节点A来连接到整棵树上的，所以删除节点A后，该子树脱落，强联通分量增加；​割边： 证明：若节点A的儿子B，LOW[B]&gt;DFN[A] ，则以B为根节点的子树是由A——B这条边连接到整棵树中的，所以删除A——B，该子树脱落，强联通分量增加； 作为一个程序员，我们看重的不能只有思想，还要有代码：12345678910111213141516171819202122232425262728293031323334353637void Tarjan(int x)&#123; int child=0; DFN[x]=LOW[x]=++_num; for(R II i=head[x];i;i=aa[i].up) &#123; R II go=aa[i].to; if(!DFN[go])&#123; child++; fa[go]=x; Tarjan(go); if(LOW[go]&gt;DFN[x]) ... // x 和 go所连的边是一条割边； LOW[x]=min(LOW[go],LOW[x]); if(LOW[go]&gt;=DFN[x]&amp;&amp;x!=root) bit[x]=1; // x 是根时 ，x 是一个割点； if(x==root&amp;&amp;child&gt;1) bit[x]=1; // x 不是根时 ，x 是割点； &#125; else&#123; if(go!=fa[x])&#123; LOW[x]=min(LOW[x],DFN[go]); &#125; &#125; &#125;&#125;for(int i=1;i&lt;=n;i++)// 原图不一定是一个强联通分量；&#123; if(!DFN[i])&#123; root=i; Tarjan(i); &#125;&#125; by pretend-fal；END；]]></content>
      <tags>
        <tag>algorithm of OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MST]]></title>
    <url>%2F2018%2F04%2F08%2FMST%2F</url>
    <content type="text"><![CDATA[我们有一个无向图，然后要求生成一棵边权之和最小的树 首先，我们可以暴力，枚举每一条边选不选，然后计算边权和，更新答案，必定会TLE，这是显然的； 那么我们需要一种较为高效的算法来解决这种问题，这时候，我们就可以学一下MST（最小生成树）的Kruskal算法了 这个算法用到了一些贪心的思想，就是我们每次选当前待选的边权最小的那条边，如果这条边符合性质，我们就把它加入到树中，否则，我们换下一条边，一直重复这个过程，知道我们加入了n-1条边（n为节点数）； 那么显然我们是要排序的，根据边权大小由小到大排序，每次取出一条边，判断是否合法的方法是用并查集，如果两个端点在一个集合中，说明这两个点一定在此之前由一些更短的边在连接其它的点的时候将这两个点连入了一个集合，所以当前边是没必要选的，且不可以选，不然违反了树的性质，有了环，如果两个端点不在一个集合，我们就把这两个点连入一个集合，处理完当前的边后，继续下一条边，直至结束； 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define II long long#define I 223456using namespace std;II n,m,ans;II fa[I];struct node &#123; II x,y,flow; friend bool operator &lt; (node a1,node a2) &#123; return a1.flow&lt;a2.flow; &#125;&#125;aa[I];II find(II x) &#123; return fa[x]==x ? x : fa[x]=find(fa[x]); &#125;void join(II x,II y) &#123; fa[x]=y; &#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); for(II i=1;i&lt;=m;i++) &#123; II x,y,z; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z); aa[i].x=x;aa[i].y=y; aa[i].flow=z; //选择结构体存边，保证不会出现乱的情况； &#125; sort(aa+1,aa+m+1); //贪心排序； for(II i=1;i&lt;=n;i++) fa[i]=i; //初始化，每个点都分别在一个不同的集合里； for(II i=1;i&lt;=m;i++) &#123; if(find(aa[i].x)!=find(aa[i].y)) &#123; //判断是否在一个集合里； join(find(aa[i].x),find(aa[i].y)); //连入树中； ans+=aa[i].flow; //ans加上当前边权； &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 由于时间紧迫，这篇文章没有图片解释，见谅；by pretend-fal；END；]]></content>
      <tags>
        <tag>algorithm of OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ST表]]></title>
    <url>%2F2018%2F04%2F08%2FST%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[求最大值 f ( i , j ) 是从 i 到 $i+2^j$ 的最大值，ennnnnnnnnnnnnn， 首先我们用倍增的思想 $$ f[j][i]=max(f[j][i-1],f[j+(o&gt;&gt;1)][i-1]) $$ 因为当前区间可以分为前半段和后半段，那么当前区间的最大值就是两端最大值的 $max$ 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define II int#define R register#define I 123456using namespace std;II f[I][30];II n,q;int main()&#123; scanf("%d%d",&amp;n,&amp;q); for(R II i=1;i&lt;=n;i++) scanf("%d",&amp;f[i][0]); for(R II i=1;(1&lt;&lt;i)&lt;=n;i++) // 这里(1&lt;&lt;j)&lt;=n； &#123; R II o=1&lt;&lt;i; for(R II j=1;j&lt;=n-o+1;j++) // 这里要j&lt;=n-o+1； f[j][i]=max(f[j][i-1],f[j+(o&gt;&gt;1)][i-1]); &#125; while (q--) &#123; R II l,r,ans=-1e9; scanf("%d%d",&amp;l,&amp;r); R II o=log(r-l+1)/log(2); ans=max(f[l][o],f[r-(1&lt;&lt;o)+1][o]); printf("%d\n",ans); &#125; exit(0);&#125;]]></content>
      <tags>
        <tag>algorithm of OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手工开栈]]></title>
    <url>%2F2018%2F04%2F08%2F%E6%89%8B%E5%B7%A5%E5%BC%80%E6%A0%88%2F</url>
    <content type="text"><![CDATA[123int size = 256 &lt;&lt; 20; // 256MB char p = (char)malloc(size) + size; asm("movl %0, %%esp\n" :: "r"(p)); 这段代码里可能有些关键字游戏地方没办法用，【摊手】]]></content>
      <tags>
        <tag>tools of OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对拍]]></title>
    <url>%2F2018%2F04%2F08%2F%E5%AF%B9%E6%8B%8D%2F</url>
    <content type="text"><![CDATA[首先我们有三个程序，bao_li.cpp，zheng_jie.cpp，data.cpp 全部运行后有三个exe 然后写一个bat ————————————-~~~———————————— 1234567:againdata.exe &gt; input.txtbao_li.exe &lt; input.txt &gt; bao_li.txtzheng_jie.exe &lt;input.txt &gt; zheng_jie.txtfc bao_li.txt zheng_jie.txtif not errorlevel 1 goto againpause 下面的是每一行的解释 1234567891011121314:again // 开始data.exe &gt; input.txt // 从data中产生数据，放到input.txt中bao_li.exe &lt; input.txt &gt; bao_li.txt // 把input.txt中的数据通过bao_li.exe运行，并把运行数据放到bao_li.txt中zheng_jie.exe &lt;input.txt &gt; zheng_jie.txt // 同上fc bao_li.txt zheng_jie.txt // 比较运行出的两组数据if not errorlevel 1 goto again // 若相同回到开始pause // 否则暂停 这个文件可以用.txt写好，然后后缀改为.bat ————————————~~~————————————– by pretend-fal END]]></content>
      <tags>
        <tag>tools of OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[problem1]]></title>
    <url>%2F2018%2F04%2F08%2Fproblem1%2F</url>
    <content type="text"><![CDATA[lxw’s adventures 题目名称 桌布 颜色 银行卡 文件名 tablecloth.cpp/c/pas color.cpp/c/pas card.cpp/c/pas 时间限制 1s 1s 1s 空间限制 128MB 128MB 128MB 桌布题目背景​ 围绕着一张桌子，lxw 开始了 Ta 的装饰 题目描述​ Ta 先在这张桌子上放了一张桌布，这张桌布呢，上面画了张图，就是那种 OI 中的有点和边的图，然后呢，这个图是一个联通块，而且边是无向的，然而 lxw 不喜欢一个联通块的图，Ta 想通过破坏一些边来使得这个图变成 $k$ 个联通块，然而每条边都是有脾气的 $w$，假设这个脾气值是 $w_i$ 那么 lxw 想要把这条边拆掉就要忍受 $w_i$ 的怒气，所以呢，lxw 想知道为了达到 Ta 的目的，至少需要忍受多少怒气，然而 lxw 那么可爱，所以这个艰难的任务就交给你来完成了 QAQ 输入格式​ 第一行三个数，$n,m,k$ ​ 接下来 $m$ 行，每行三个数 $x_i , y_i , z_i$ 代表 $x_i$ 和 $y_i$ 之间有一条怒气值为 $z_i$ 的边 输出格式​ 一行一个数，即 lxw 最少所需要忍受的怒气值 样例输入9 15 41 2 1547043541 3 6234409601 4 108280321 5 6226336541 6 1144269281 7 1090342021 8 1040249981 9 986575923 1 82976 1 11159 3 272441 9 71654 3 20571 2 183492 5 19431 样例输出213547088 数据范围与约定 $20 \% n\leq 20,m\leq 20$ $60\% n\leq10^3,m\leq2\times10^3$ $100\% n\leq10^5 , m\leq2\times10^5 $怒气值$\leq 10^9$ 颜色题目背景​ 终于，lxw 在你的帮助下用最小的花费做好了桌布，但是这时，天上掉下来了一张银行卡 wow，而且还有一张纸条，写着恭喜您成为我们第233666位幸运用户，这张卡您可以随便刷，但是三天后会被收回 ，于是lxw变成了三天的有钱人，就买了一个带有一个好多颜色的长条布 题目描述​ 这张长条布可以看做一个长度为 $n$ 的格子，且只有一行，lxw 看着这张布，一会可能就把其中某个格子的颜色换成了另一种颜色，一会可能问你在 [l,r] 这个区间中，所有的颜色为 $c$ 的格子中，最靠近当前区间中点的格子的位置 输入格式​ 第一行，一个 $n$ ，接下来 $n$ 个数，为每个格子初始颜色，接下来一行，一个 $Q$ ，表示 lxw 的操作个数，再接下来 $Q$ 行，形式为 C x c 或者Q l r c 表示把 $x$ 这个位置的颜色改为 $c$ ，或者询问 [l,r] 这个区间 $c$ 这个颜色(如题) 输出格式​ 对于每个 $Q$ 操作，输出一个数，表示位置(如题)，如果距离一样，输出靠左的位置，如果没有，输出$-1$ 样例输入41 8 5 46C 4 1Q 2 4 3Q 2 2 8C 3 0Q 3 3 1C 1 0 样例输出-12-1 数据范围与约定 $30\% \,\,\,\,n\leq100 ,m\leq100$ $60\% \,\,\,\,n\leq10^3, m\leq10^3$ $100\% \,\,\,\, n\leq10^5 m\leq10^5 \,\,\,\, 保证 r+l 是偶数且 c\leq9$ 银行卡题目背景​ 三天过去了，终于银行卡要被收走了，lxw 十分伤心 题目描述​ 在银行卡消失的那一瞬间，lxw 看了一眼这银行卡号，发现这张银行卡的号码每一位都是∈[0,9]，而且对于每一个[0,9]中的数字，下一位只能是某几位数字之一，比如：$3$ 后面只能是 $0,1,5$ 之一，那么号码中只能存在...30... 、...31... 、...35...这样的形式，现在 lxw 告诉你了每一位后面可以跟的数字集合，请你告诉 Ta 可能有多少种号码满足这个限制 输入格式​ 第一行一个 $n$ ，表示号码长度，接下来 $10$ 行，每行开始有一个数 $k$ 接下来 $k$ 个数，表示如题，$10$ 行分别代表 [0,9] 中的每个数的信息 输出格式​ 一行，一个数，即方案数，由于 $ans$ 可能很大，要求对 $20010827$ 取模后输出 样例输入32 0 32 0 12 5 13 0 6 41 12 2 402 7 22 0 32 2 4 样例输出33 数据范围与约定 $10\% \,\,\,\, n\leq5$ $60\% \,\,\,\, n\leq10^6$ $100\% \,\,\,\, n\leq10^{18} $ THE ENDBY Peipei lxw’s adventures solution桌布（teblecloth）​ 是不是一下子就想到了生成树？？！ ​ 其实就是生成树+贪心 ​ 首先我们从大到小加边，直到再加一条边就由 $k$ 个联通块变为 $k-1$ 个联通块为止 ​ 然后呢，已经加进去的边是不属于我们要删的边集的，那么对于剩下的没加进去的边，只有一部分是需要删的，为什么呢？？！ ​ 如果说，在剩下的边中，由一些边所连的两个点已经在一个联通块了，那么这条边不应该删，因为这条边删了不会影响联通块数量，但是会是 $ans$ 变大，与我们的意志相违背，所以，我们要把没有加进去的边中，已经连接两个属于同一联通块的边加进图里 ​ 做完这些后还没有加进去的边就是需要删的边 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#define II int#define LO long long#define IL inline#define R register#define I 1023546using namespace std;template &lt; typename T &gt; IL void of (R T &amp;a) &#123; R char c=getchar (); R T w=1, p=0; while (!isdigit(c)) &#123; if(c=='-') w=-1; c=getchar (); &#125; while (isdigit(c)) &#123; p=p*10+c-'0'; c=getchar (); &#125; a=w*p;&#125;/* -------------------- Peipei -------------------- */II n,END,all,m,k;LO ans;II fa[I];struct POI &#123; II x,y; friend bool operator &lt; (POI a1,POI a2) &#123; return a1.x==a2.x ? a1.y&lt;a2.y : a1.x&lt;a2.x; &#125;&#125;;map &lt;POI,II&gt; nu;struct UI &#123; II x,y,w; friend bool operator &lt; (UI a1,UI a2) &#123; return a1.w&lt;a2.w; &#125;&#125; aa[I];IL II find(R II x) &#123; return fa[x]==x ? x : fa[x]=find(fa[x]) ; &#125;int main()&#123; freopen("tablecloth.in","r",stdin); freopen("tablecloth.out","w",stdout); of(n); of(m); of(k); R II len=1; for(R II i=1;i&lt;=m;i++) &#123; of(aa[len].x); of(aa[len].y); of(aa[len].w); if(aa[len].x&gt;aa[len].y) swap(aa[len].x,aa[len].y); if(nu.count((POI) &#123;aa[len].x,aa[len].y&#125;)) &#123; aa[nu[(POI) &#123;aa[len].x,aa[len].y&#125;]].w+=aa[len].w; &#125; else &#123; nu[(POI) &#123;aa[len].x,aa[len].y&#125;]=len; len++; &#125; &#125; m=len-1; for(R II i=1;i&lt;=m;i++) ans+=aa[i].w; sort(aa+1,aa+m+1); for(R II i=1;i&lt;=n;i++) fa[i]=i; all=n; for(R II i=m;i;i--) &#123; R II x=find(aa[i].x), y=find(aa[i].y); if(x!=y) &#123; if(all==k) &#123; END=i; break ; &#125; fa[x]=y; all--; &#125; ans-=aa[i].w; &#125; for(R II i=1;i&lt;=END;i++) if(find(aa[i].x)==find(aa[i].y)) ans-=aa[i].w; printf("%lld\n",ans); exit(0);&#125; 颜色（color）​ 一行 $n$ 个格子，要求支持以下操作： 单点修改 [l,r] 中给定颜色最靠中间的位置 那么我们开 $c$ 棵线段树，分别维护每个颜色，那么这个题就变为了这样子 [x] 单点修改就是在原来颜色中删节点，在新的颜色中添加节点 [x] 在给定的颜色的线段树中查询最靠中间的位置 [l,r] 找中间位置，分为[l,mid] 找最右端位置 和 [mid,r] 找最左端位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#define II int#define IL inline#define R register#define I 100100using namespace std;template &lt; typename T &gt; IL void of (R T &amp;a) &#123; R char c=getchar (); R T w=1, p=0; while (!isdigit(c)) &#123; if(c=='-') w=-1; c=getchar (); &#125; while (isdigit(c)) &#123; p=p*10+c-'0'; c=getchar (); &#125; a=w*p;&#125;/* -------------------- Peipei -------------------- */II now,n,Q,l,r,ppc;II c[I];struct Tree &#123; II l,r,lp,rp; Tree () &#123;l=r=0; lp=1e9; rp=-1e9;&#125; friend Tree operator + (Tree a1,Tree a2) &#123; R Tree c; c.l=a1.l; c.r=a2.r; c.lp=min(a1.lp,a2.lp); c.rp=max(a1.rp,a2.rp); return c; &#125; IL void ag() &#123;lp=1e9; rp=-1e9;&#125;&#125; Tr[10][I*4];#define f Tr[now][o]#define ls Tr[now][o&lt;&lt;1]#define rs Tr[now][o&lt;&lt;1|1]IL void build_t(R II o) &#123; if(f.l==f.r) &#123; if(c[f.l]==now) f.lp=f.rp=f.l; return ; &#125; ls.l=f.l; ls.r=(f.l+f.r)&gt;&gt;1; rs.l=ls.r+1; rs.r=f.r; build_t(o&lt;&lt;1); build_t(o&lt;&lt;1|1); f=ls+rs;&#125;IL void del(R II o) &#123; if(f.l==f.r) &#123; if(!ppc) f.ag(); else f.lp=f.rp=f.l; return ; &#125; if(ls.r&gt;=l) del(o&lt;&lt;1); if(rs.l&lt;=r) del(o&lt;&lt;1|1); f=ls+rs;&#125;IL Tree query(R II o) &#123; if(f.l&gt;=l &amp;&amp; f.r&lt;=r) return f; if(r&lt;=ls.r) return query(o&lt;&lt;1); else if(l&gt;=rs.l) return query(o&lt;&lt;1|1); else return query(o&lt;&lt;1)+query(o&lt;&lt;1|1);&#125;int main()&#123; freopen("color.in","r",stdin); freopen("color.out","w",stdout); of(n); for(R II i=1;i&lt;=n;i++) of(c[i]); for(now=0;now&lt;=9;now++) &#123; Tr[now][1].l=1; Tr[now][1].r=n; build_t(1); &#125; R char opt; R II ll,rr,x,to,mid; of(Q); while ( Q -- ) &#123; cin &gt;&gt; opt; if(opt=='C') &#123; of(x); of(to); l=r=x; ppc=0; now=c[x]; del(1); c[x]=to; ppc=1; now=c[x]; del(1); &#125; else &#123; of(ll); of(rr); of(now); mid=(ll+rr)&gt;&gt;1; // cout&lt;&lt;mid&lt;&lt;endl; l=ll; r=mid; ll=query(1).rp; l=mid; r=rr; rr=query(1).lp; if(ll==-1e9 &amp;&amp; rr==1e9) puts("-1"); else if(ll==-1e9) printf("%d\n",rr); else if(rr==1e9) printf("%d\n",ll); else if(mid-ll&lt;=rr-mid) printf("%d\n",ll); else printf("%d\n",rr); &#125; &#125; exit(0);&#125; 银行卡（card）​ $n$ 个数字，每个位置是[0,9] 中任意一个，且[0,9] 中每一位的下一位都属于一个固定集合那么我们设 f ( i , j ) 表示 到第 i 个位置，结尾是 j 这个数字的方案数 显然 假设 $k$ 的下一位集合是 $S_k$ 那么转移为 f[i][j] += f[i-1][k] 其中 $j$ ∈ $S_k$ 但是，$n &lt;=1000000000000000000$ 那么，考虑优化 由于是线性递推，则可以用矩阵乘法加速 初始矩阵为 a[0][j]=1 其中 $j ∈ [0,9]$ 基底矩阵为 c[i][j]=1 其中 $i ∈ [0,9], j ∈ S_i$ 最后矩阵乘法快速幂即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define II int#define LO long long#define IL inline#define R register#define I 100100#define PI 20010827using namespace std;template &lt; typename T &gt; IL void of (R T &amp;a) &#123; R char c=getchar (); R T w=1, p=0; while (!isdigit(c)) &#123; if(c=='-') w=-1; c=getchar (); &#125; while (isdigit(c)) &#123; p=p*10+c-'0'; c=getchar (); &#125; a=w*p;&#125;template &lt; typename T &gt; IL void inc (T &amp;a,T b) &#123; a+=b;a&gt;=PI?a-=PI:0; &#125;/* -------------------- Peipei -------------------- */LO n;II ans;struct NU &#123; II a[10][10]; NU () &#123;memset(a,0,sizeof a);&#125; friend NU operator * (NU a1,NU a2) &#123; R NU d; for(R II i=0,x;i&lt;=9;i++) for(R II j=0;j&lt;=9;j++) for(R II k=0;k&lt;=9;k++) &#123; x=1ll*a1.a[i][k]*a2.a[k][j]%PI; inc(d.a[i][j],x); &#125; return d; &#125;&#125; a,c;int main()&#123; freopen("card.in","r",stdin); freopen("card.out","w",stdout); of(n); for(R II i=0,len,x;i&lt;=9;i++) for(of(len);len;len--) of(x), c.a[i][x]=1; for(R II i=0;i&lt;=9;i++) a.a[0][i]=1; for(n--;n;n&gt;&gt;=1, c=c*c) if(n&amp;1) a=a*c; for(R II i=0;i&lt;=9;i++) inc(ans,a.a[0][i]); printf("%d\n",ans); exit(0);&#125; end]]></content>
      <tags>
        <tag>problem of OI</tag>
        <tag>tests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEOI2018颓废记]]></title>
    <url>%2F2018%2F04%2F08%2FHEOI2018%E9%A2%93%E5%BA%9F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2018 - 4 - 7 今天啊，我们省选完了，然后呢，我的所谓的希望也结束了，嗯。。。。。大家大概都没有考到自己想要的成绩，YY也翻了，真的十分可惜，他进队我是可以服的，但是他翻了，昨天考完试，他们从教练哪里看完分，然后回来了他在床上一坐说翻了，我突然感觉替他难受，真的经历过这个事情的人才能体会到，去年noip之后，我的状态和心情，没有人真的和我谈过，lxw也根本不了解这些东西，真的什么都要自己承受，真的心累，然而差点抑郁，庆幸自己还开心地活着，然鹅我昨天考了100，我预期的保守分是115，但是结局十分尬，吃晚饭的时候，陪yy聊了一顿饭，真的感觉大家都一样，都背着自己给自己的压力以及外界给的压力，其实吧，考试而已，但是，总会出现比较，这真的十分令人恶心，还好，我昨天考试的时候，心态一直没崩，今天也是，我昨天的成绩是别人告诉我的，我没有看，今天才知道，非正式选手是没有名字的，只有编号，比如我是227，真的是日了狗，我弄到最后，连个名都没留下，去TMD，今天的T1我写了费用流，费用xjb搞，然后调了调过了四个样例，开心，而且担心，真的怕A不掉，然而我现在都不知道我T1多少分，非正式选手没人权啊，mmp，我刚刚看了分，才10分，，，完了，总分才110，还没人家D1的分高呢，，，，，突然人生失去了希望，不知道该说啥， updata 2018 - 4 - 8 今天回了学校，ennnnnnnnnnnn 昨天就回来了，只是到的比较晚，在路上和cdy谈了谈所谓的OI经验，然后到了学校后，大家都十分低沉，毕竟是翻了，然后今天跑完操，开了个小会，大概分析了下，还给了几句安慰，但是我觉得没有人会因为这几句安慰去真的放下，对啊，省一的就可以APIO和CTSC之后退役了，然而我还要苟到noip，真的是可怕，河北省太可怕了，垄断，真的是垄断，我自己的noip分太低了，以至于总和D1+D2+noip才142分，然而他们最高分都260多了，其实吧，这些真的会让人有些压抑，但是还是要面对，就像noip之后，没有人会特别在意你的感受，毕竟大家还是看成绩说话的，那天和YY说我noip的时候，他说我是翻车，真的，那一刻我觉得还是会有人去认可我的，但是，当时心情特别好，毕竟我最怕别人认为我的能力不足以到达至少平均水平，然而没有人进队这个事情已经发生了，什么都过去了这种话，真的在我们这些亲身经历过省选失败的人的口中讲出来，全是假的，谁会真的说过去就过去啊，大家真的是都顶着足够的压力，在前面的有学校的压力，在后面的有自己的压力，这方面谁也不会差给谁，大家都够辛苦，而这个世界又太残酷了，真的世界在疯狂，我们如果在这么顺其自然真的是会挂的，要和世界gang，垃圾搜狗输入法，连gang都打不出来 updata 2018 - 5 - 8 刚刚看了一些 $HEOI2018$ 的感言，ennnnnnnnnn，怎么说呢，我看到了省二翻盘进队的 $dalao$ 的 $blog$，还有非正式 $rank 2$ 的 $blog$ ennnnnnnnnnnn，不知道为啥，今天点的这么准，首先省二翻盘一直是我想要的，然后呢，我是非正式 $rank 3$ ，所以呢，看完这两篇，其实心里肯定是不太好受的 我自己也清楚，我省选 $110$ 分真的菜，所谓非正式 $rank 3$ ，有个P用，放在正式选手里还要排在后面 $noip2017$ 完了之后，我觉得OI真的有点无聊，然而省选前我就特别想进队，就像省二翻盘一样，然而自己还是菜，然后呢，就去省选了，$Day1$ 我以 $100$ 分的成绩成为了非正式 $rank 1 $， 然后 $Day2$ $10$ 分，我自己都不敢信，因为我 $Day1$ 估分是 $115$ ，$Day2$ 估分是 $135$ ，差的有点多，我当时是在回来的车上看的成绩，用的教练的手机，当时我记得快到晚上了，我看见 $227$ 号后面跟的 $10 | 0 | 0$ ，之后，我自己都感觉到了自己的脸僵了一下，脑子一片空白，就算有一句话也是质问、不甘、害怕这个分数 然后啊，我真的六神无主，睡觉也睡不着了，也没有手机，不知道干点什么，然后拿出了放在后排的笔记本，找了半天，确定 $Win10$ 是没有扫雷之类的游戏之后，写了一些话，就是《HEOI2018颓废记》的第一段，这里我都不能说当时写的是退役感言，我不能退役，这是让我更加尴尬而且我认为很难堪的一件事 然后回来后学文化课，什么也不会，真的是OI菜如狗，文化课也菜如狗，再后来报名参加 $CTSC$ 和 $APIO$ ，然而 $CTSC$ 不要省二，ennnnnnnnn，这里不得不说一句，省二没人权，真的没人权，然后成功报上了 $APIO $ 接着5.1就来集训，到现在，大家都没什么心思刷题，我甚至无聊的时候自己写了个2048 在 $blog$ 里，有兴趣的同学可以找一找，然后玩一玩 省一的七个人参加完这两场比赛就可以退役了，所以他们完全可以颓、放松，然而我不行啊，我特么是个省二啊，还要再来一次 $noip$ 啊，然而没什么用，背负着罪恶感，然后颓，感觉自己有点破罐破摔的感觉了 然后 6号，省一的走了，我还在机房苟着，高一的也集训完了，不大的机房就剩三个人了，真的冷清，超级没意思 然后现在呢 我刚刚做了 $APIO$ 的测试题，会一道 A+B，一道 序列倒序输出，然后就特么一个也不会了，mayi，怕不是 $APIO$ 要打铁了，怕怕 然后突然想起我写这些的起始点，是看到了几篇 $blog$ ，然后我打算把我的成绩和正式选手的成绩放在这里 ennnnnnnn 突然没什么想说的了 今天先到此为止吧，要是以后有再更 顺便把密码删了 233]]></content>
      <tags>
        <tag>day by day</tag>
      </tags>
  </entry>
</search>
