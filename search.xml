<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>for_lxw</title>
      <link href="/2018/04/29/for_lxw/"/>
      <url>/2018/04/29/for_lxw/</url>
      <content type="html"><![CDATA[<script>if("llxwei"==prompt("请输入密码")){alert("正确");}else{alert("错误");location="http://pretend-fal.ml/";}</script><p><strong>忘记了哪天相遇</strong><br><strong>我们互不相识</strong><br><strong>后来我们熟悉了彼此</strong><br><strong>以一个我现在又庆幸有后悔的关系</strong><br><strong>开始了我们之间的磕磕绊绊 </strong>   </p><p><strong>后来啊</strong><br><strong>你转了学</strong><br><strong>我们便再也没了什么话 </strong> </p><p><strong>又是一个我忘了的日子</strong><br><strong>你找我要备注</strong><br><strong>然后开启了我们之间的新的一页 </strong> </p><p><strong>这一页上</strong><br><strong>我开心于有你的陪伴</strong><br><strong>不知不觉</strong><br><strong>我们都大了</strong><br><strong>虽然不想承认</strong><br><strong>但是抵不住似水年华</strong>  </p><p><strong>最近是各所学校强加给高二人的成人礼</strong><br><strong>但是这真的</strong><br><strong>让人有些醒悟</strong><br><strong>至少正视了自己的年龄</strong><br><strong>隐隐约约的知道了自己面临的是什么</strong>  </p><p><strong>狗子</strong><br><strong>我觉得成人并不快乐</strong><br><strong>但是希望你能有</strong></p><p><strong>最少的烦恼</strong><br><strong>最多的笑容</strong><br><strong>和</strong><br><strong>虽然不可爱</strong><br><strong>但是现在是最可爱的我</strong></p><p><img src="/pic/gz.bmp" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> day by day </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各类模板(日常更新)</title>
      <link href="/2018/04/22/%E5%90%84%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
      <url>/2018/04/22/%E5%90%84%E7%B1%BB%E6%A8%A1%E6%9D%BF/</url>
      <content type="html"><![CDATA[<p>这篇Blog是一些板子。。。。。。。。。。。。。。</p><a id="more"></a><p>[TOC]</p><p>#高精 + - *</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">of</span> <span class="params">(R T &amp;a)</span> </span>&#123;</span><br><span class="line">R <span class="keyword">char</span> c=getchar (); R T w=<span class="number">1</span>, p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>; c=getchar (); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123; p=p*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar (); &#125;</span><br><span class="line">a=w*p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------- Peipei -------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[I];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NU</span> &#123;</span></span><br><span class="line">II a[I];</span><br><span class="line">NU () &#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">a[<span class="number">0</span>]=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(R II i=a[<span class="number">0</span>];i;i--) a[a[<span class="number">0</span>]-i+<span class="number">1</span>]=s[i]-<span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> NU <span class="keyword">operator</span> + (NU a1,NU a2) &#123;</span><br><span class="line">R NU c; R II jin=<span class="number">0</span>; c.a[<span class="number">0</span>]=max(a1.a[<span class="number">0</span>],a2.a[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=c.a[<span class="number">0</span>];i++)</span><br><span class="line">&#123;</span><br><span class="line">c.a[i]=a1.a[i]+a2.a[i]+jin;</span><br><span class="line">jin=c.a[i]/PI; </span><br><span class="line">c.a[i]%=PI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (jin) c.a[++c.a[<span class="number">0</span>]]=jin%PI, jin/=PI;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> NU <span class="keyword">operator</span> - (NU a1,NU a2) &#123;</span><br><span class="line">R NU c=a1;</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=c.a[<span class="number">0</span>];i++) c.a[i]=a1.a[i]-a2.a[i];</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=c.a[<span class="number">0</span>];i++) </span><br><span class="line"><span class="keyword">if</span>(c.a[i]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">c.a[i]+=PI;</span><br><span class="line">c.a[i+<span class="number">1</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!c.a[c.a[<span class="number">0</span>]] &amp;&amp; c.a[<span class="number">0</span>]!=<span class="number">1</span>) c.a[<span class="number">0</span>]--;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">friend</span> NU <span class="keyword">operator</span> * (NU a1,NU a2) &#123;</span><br><span class="line">R NU c; R II w;</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=a1.a[<span class="number">0</span>];i++)</span><br><span class="line"><span class="keyword">for</span>(R II j=<span class="number">1</span>;j&lt;=a2.a[<span class="number">0</span>];j++)</span><br><span class="line">&#123;</span><br><span class="line">w=c.a[i+j<span class="number">-1</span>]+<span class="number">1l</span>l*a1.a[i]*a2.a[j];</span><br><span class="line">c.a[i+j]+=w/PI;</span><br><span class="line">c.a[i+j<span class="number">-1</span>]=w%PI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=a1.a[<span class="number">0</span>]+a2.a[<span class="number">0</span>];i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(c.a[i]) c.a[<span class="number">0</span>]=i;</span><br><span class="line">c.a[i+<span class="number">1</span>]+=c.a[i]/PI;</span><br><span class="line">c.a[i]%=PI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">R II wei=a[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%1d"</span>,a[wei--]);</span><br><span class="line"><span class="keyword">while</span> (wei) <span class="built_in">printf</span>(<span class="string">"%1d"</span>,a[wei--]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.in();b.in();</span><br><span class="line">c=a+b; c.out();</span><br><span class="line">c=a-b; c.out(); <span class="comment">// 一般这里a 是大于b 的</span></span><br><span class="line">c=a*b; c.out();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FHQ-Treap"><a href="#FHQ-Treap" class="headerlink" title="FHQ Treap"></a>FHQ Treap</h1><p><a href="http://pretend-fal.ml/2018/04/22/FHQ%20Treap/" target="_blank" rel="noopener">Blog</a></p><h1 id="Tire-and-AC自动机"><a href="#Tire-and-AC自动机" class="headerlink" title="Tire and AC自动机"></a>Tire and AC自动机</h1><p><a href="http://pretend-fal.ml/2018/04/18/Tire%20and%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA/" target="_blank" rel="noopener">Blog</a></p><h1 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h1><p><a href="http://pretend-fal.ml/2018/04/10/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/" target="_blank" rel="noopener">Blog</a></p><h1 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h1><p><a href="http://pretend-fal.ml/2018/04/10/%E7%82%B9%E5%88%86%E6%B2%BB/" target="_blank" rel="noopener">Blog</a></p><h1 id="gcd-amp-exgcd"><a href="#gcd-amp-exgcd" class="headerlink" title="gcd&amp;exgcd"></a>gcd&amp;exgcd</h1><p><a href="http://pretend-fal.ml/2018/04/08/gcd&amp;exgcd/" target="_blank" rel="noopener">Blog</a></p><h1 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h1><p><a href="http://pretend-fal.ml/2018/04/08/%E7%B4%A0%E6%95%B0%E7%AD%9B/" target="_blank" rel="noopener">Blog</a></p><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 123546</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">of</span> <span class="params">(R T &amp;a)</span> </span>&#123;</span><br><span class="line">    R <span class="keyword">char</span> c=getchar (); R T w=<span class="number">1</span>, p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>; c=getchar (); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123; p=p*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar (); &#125;</span><br><span class="line">    a=w*p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------- Peipei -------------------- */</span></span><br><span class="line"></span><br><span class="line">II tot=<span class="number">1</span>,n,m,s,t,ans,Inf=<span class="number">1e8</span>;</span><br><span class="line">II head[I], inq[I], bit[I];</span><br><span class="line"><span class="built_in">queue</span> &lt;II&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UUI</span> &#123;</span> II to,up,flow; &#125; aa[I];</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">join</span><span class="params">(R II x,R II y,R II z)</span> </span>&#123;</span><br><span class="line">    aa[++tot]=(UUI) &#123;y,head[x],z&#125;; head[x]=tot;</span><br><span class="line">    aa[++tot]=(UUI) &#123;x,head[y],<span class="number">0</span>&#125;; head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n&lt;&lt;<span class="number">1</span>;i++) inq[i]=<span class="number">0</span>;</span><br><span class="line">    Q.push(s); inq[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        R II x=Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span>(R II i=head[x],go;i;i=aa[i].up)</span><br><span class="line">        &#123;</span><br><span class="line">            go=aa[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!inq[go] &amp;&amp; aa[i].flow) &#123;</span><br><span class="line">                inq[go]=inq[x]+<span class="number">1</span>;</span><br><span class="line">                Q.push(go);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inq[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL II <span class="title">dfs</span><span class="params">(R II x,R II a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==t || !a) <span class="keyword">return</span> a;</span><br><span class="line">    R II now_f=<span class="number">0</span>,f;</span><br><span class="line">    <span class="keyword">for</span>(R II &amp;i=bit[x],go;i;i=aa[i].up)</span><br><span class="line">    &#123;</span><br><span class="line">        go=aa[i].to;</span><br><span class="line">        <span class="keyword">if</span>(inq[go]==inq[x]+<span class="number">1</span> &amp;&amp; (f=dfs(go,min(aa[i].flow,a)))&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            aa[i].flow-=f;</span><br><span class="line">            aa[i^<span class="number">1</span>].flow+=f;</span><br><span class="line">            a-=f; now_f+=f;</span><br><span class="line">            <span class="keyword">if</span>(!a) <span class="keyword">return</span> now_f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now_f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line"></span><br><span class="line">    of(n); of(m); of(s); of(t); s+=n;</span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n;i++) join(i,i+n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">1</span>,x,y;i&lt;=m;i++) &#123;</span><br><span class="line">        of(x); of(y);</span><br><span class="line">        join(x+n,y,Inf);</span><br><span class="line">        join(y+n,x,Inf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (bfs()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n&lt;&lt;<span class="number">1</span>;i++) bit[i]=head[i];</span><br><span class="line">        ans+=dfs(s,Inf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm of OI </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FHQ Treap</title>
      <link href="/2018/04/22/FHQ%20Treap/"/>
      <url>/2018/04/22/FHQ%20Treap/</url>
      <content type="html"><![CDATA[<p><del>FHQ Treap万岁，摒弃Splay</del></p><a id="more"></a><p>ennnnnnnnn 说一说FHQ Treap，为什么这么推崇FHQ呢？？ </p><ul><li><del>只会FHQ</del></li><li>Splay极其容易被卡成 $dog$ 但是很少听到FHQ被卡</li><li>FHQ支持持久化，但是Splay不行</li></ul><p>所以推荐FHQ</p><p>还有下文里的<code>平衡树的性质</code> 可以理解为一个节点的左子树所有权值都是小于当前节点权值的，右子树的所有权值都是大于当前节点权值的</p><hr><p>这是个目录<br>[TOC]</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>首先FHQ是一种平衡树，而且是一种Treap的延伸物[^我是这么想的] ，然后首先你可以先学Treap，然后再来看这篇，这样子可能学起来就简单一些了，然后就会忘记Treap怎么码，只会FHQ了，反正我现在码Treap是要现推的</p><p>FHQ Treap 又叫 <code>非旋Treap</code> 顾名思义，就是不旋转的Treap，总体来讲，会把Treap拆成一条条的链/子树，通过各种分离和拼接，来完成维护平衡树的工作  </p><p>至于怎么拆成链/子树，可以看这个图</p><p><img src="/pic/5.bmp" alt=""></p><p>红线就是拆成的一条条的链</p><h1 id="节点信息"><a href="#节点信息" class="headerlink" title="节点信息"></a>节点信息</h1><ul><li>$ls,rs$ 左右子树<strong>标号</strong></li><li>$ra$ 优先级(rand())</li><li>$w$ 该节点权值</li><li>$siz$ 该子树大小</li><li>。。。。。一些题里要求的</li></ul><h1 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h1><h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>分离的意思，就是把一颗Treap以一种条件分离成两棵Treap，新的Treap是可以为空的，我们这里以权值为例，那么 $split$ 就可以是按照<code>大于 w ，小于等于 w</code> 来分离成两棵Treap：$l$ 和 $r$ </p><p>同时，根据定义我们有：</p><blockquote><p>$l$ 中的每一个节点的权值都小于等于 $w$ </p><p>$r$ 中的每一个节点的权值都大于 $w$</p></blockquote><h3 id="code："><a href="#code：" class="headerlink" title="code："></a>code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;l,<span class="keyword">int</span> &amp;r,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) &#123; l=r=<span class="number">0</span>; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    <span class="keyword">if</span>(Tr[x].w&lt;=w) &#123;</span><br><span class="line">        l=x;  <span class="comment">// 这里必须先赋值</span></span><br><span class="line">        split(Tr[x].r,Tr[l].r,r,w);</span><br><span class="line">        up(l);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r=x;</span><br><span class="line">        split(Tr[x].l,l,Tr[r].l,w);</span><br><span class="line">        up(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>我尽量写的能看懂了</del>  </p><h3 id="code解释"><a href="#code解释" class="headerlink" title="code解释"></a>code解释</h3><p>由于平衡树的性质，如果当前节点的 $w_x$ 是小于等于我的分离接线 $w$ 点的话，那么当前节点的左子树任何一个权值 $w_l$ 都是小于 $w$ 的，那么我们就把当前节点以及左子树全部给 $l$ ，就像这张图 </p><p><img src="/pic/6.bmp" alt=""></p><p>这时候就可以发现我们当前节点的右子树是还没有确定的，因为这里面可能大于小于 $w$ 的节点都可能存在，我不画图了，自己考虑平衡树，然后我们现在要去考虑右子树，所以我们传入了 $Tr[x].r$ </p><p>然后我们发现现在的 $l$ 的右子树是空的，所以如果之后向 $l$ 中加东西的话，就往右子树上加就好了，这里解释下有这样一些条件使得我们要往右子树加，而不是左子树</p><ul><li>右子树是空的</li><li>我们之后处理的是当前节点的右子树，里面的任何一个权值都大于当前节点的权值，所以根据平衡树的性质，我们之后的点要放到右子树中</li></ul><p>这样就差不多了，至于右子树，自行参考左子树</p><p>还有就是传址</p><p>因为我们要修改一些儿子的编号，这样传址就可以直接在 $l=x$ 或者 $r=x$ 时直接修改了</p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><h3 id="基本定义-1"><a href="#基本定义-1" class="headerlink" title="基本定义"></a>基本定义</h3><p>这个是合并，就是把两个Treap合并成一个</p><p><del>有分离就肯定有合并。。。。。</del></p><p>我们首先保证一个前提</p><blockquote><p>$l$ 的所有节点权值都是$&gt;=r$ 的权值的</p></blockquote><h3 id="code：-1"><a href="#code：-1" class="headerlink" title="code："></a>code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">merge</span><span class="params">(R II l,R II r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l*r==<span class="number">0</span>) <span class="keyword">return</span> l+r;</span><br><span class="line">    <span class="keyword">if</span>(Tr[l].ra&gt;Tr[r].ra) &#123;</span><br><span class="line">        Tr[l].r=merge(Tr[l].r,r);</span><br><span class="line">        up(l); <span class="keyword">return</span> l;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Tr[r].l=merge(l,Tr[r].r);</span><br><span class="line">        up(r); <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="code解释-1"><a href="#code解释-1" class="headerlink" title="code解释"></a>code解释</h3><p>我们先有一张图：</p><p><img src="/pic/7.bmp" alt=""></p><p>如果当前 $l$ 节点的优先级 $&gt;$ 当前 $r$ 节点优先级，那么我们就把 $r$ 放到 $l$ 的右子树中，这样我们保证了平衡树的性质，但是如果 $l$ 有右子树怎么办。。。。。。。</p><p>这就化为了一个子问题，我们把 $r$ 和 $l$ 的右子树合并成一个Treap，然后作为 $l$ 的新右子树就OK了</p><p>所以我们下传的是 $merge(Tr[l].r,r)$ </p><p>这个比较简单，至于右子树，自行参考左子树</p><h1 id="int-main"><a href="#int-main" class="headerlink" title="int main"></a>int main</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span> II l,r,w,siz,ra; &#125; Tr[I];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    of(n);</span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; of(x);</span><br><span class="line">        Tr[i]=(Tree) &#123;<span class="number">0</span>,<span class="number">0</span>,x,<span class="number">1</span>,rand()&#125;;</span><br><span class="line">        root=merge(root,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分离</span></span><br><span class="line">    <span class="keyword">int</span> l,r,w;</span><br><span class="line">    of(w);</span><br><span class="line">    split(root,l,r,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$root$ 就是当前的整棵Treap的根节点编号</p><p>$l$ 和 $r$ 就是分离出来的两棵Treap的根节点编号</p><h1 id="一些注意"><a href="#一些注意" class="headerlink" title="一些注意"></a>一些注意</h1><ul><li>我们在进行 $merge$ 和 $split$ 时，每次操作时，我们都保证了函数里左子树永远是 $l$ 右子树永远是 $r$ 这样我们才能保证平衡树的性质</li><li>注意每个函数的 $return$ 条件</li></ul><h1 id="EX函数"><a href="#EX函数" class="headerlink" title="EX函数"></a>EX函数</h1><p>去看例题好了。。。。。。。。。。。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
        <tags>
            
            <tag> algorithm of OI </tag>
            
            <tag> FHQ Treap </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tire and AC自动机</title>
      <link href="/2018/04/18/Tire%20and%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>/2018/04/18/Tire%20and%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p>[TOC]</p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>Trie 是一个前置知识，所以我就从网上找了些介绍，然后借(Ctrl+C)鉴(Ctrl+V)过来了，所以要是有些神乎其神的地方我要是解释不了，大家可以自行百度 QAQ</li><li>然后是 AC自动机 这个是这篇 blog 主要讲的东西，但是我觉得对于这种字符串的东西，还是口胡的地方比较多，所以有关 AC自动机 的篇幅也不会太长，主要是在黑板上画来画去 </li><li>然后我们就开始了</li></ul><hr><h1 id="Trie-or-字典树"><a href="#Trie-or-字典树" class="headerlink" title="Trie or 字典树"></a>Trie or 字典树</h1><h5 id="字典树的概念"><a href="#字典树的概念" class="headerlink" title="字典树的概念"></a>字典树的概念</h5><ul><li>字典树，因为它的搜索快捷的特性被单词搜索系统使用，故又称单词查找树。它是一种树形结构的数据结构。之所以快速，是因为它用空间代替了速度。</li></ul><h5 id="那什么是Trie？？！"><a href="#那什么是Trie？？！" class="headerlink" title="那什么是Trie？？！"></a>那什么是Trie？？！</h5><ul><li>其实就是把一些字符串连到一个根节点上，既然有根节点了，那一定有了一颗树，那么，我们把这些串形成的树叫作 <strong>Trie</strong>；</li></ul><h5 id="字典树有三个基本性质："><a href="#字典树有三个基本性质：" class="headerlink" title="字典树有三个基本性质："></a>字典树有三个基本性质：</h5><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符</li><li>从根节点到某一个节点，路径上经过的字符连接起来，就是该节点对应的字符串</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><h4 id="But-why？？！"><a href="#But-why？？！" class="headerlink" title="But why？？！"></a>But why？？！</h4><h4 id="because-这是基本性质"><a href="#because-这是基本性质" class="headerlink" title="because 这是基本性质"></a>because 这是基本性质</h4><p>代码 code ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 123456</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">of</span> <span class="params">(R T &amp;a)</span> </span>&#123;</span><br><span class="line">R <span class="keyword">char</span> c=getchar (); R T w=<span class="number">1</span>, p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>; c=getchar (); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123; p=p*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar (); &#125;</span><br><span class="line">a=w*p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------- Peipei -------------------- */</span></span><br><span class="line"></span><br><span class="line">II n,Q,len,tot,root;</span><br><span class="line">II a[I];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">POI</span> &#123;</span> II up[<span class="number">10</span>]; II is; &#125; Tr[I];</span><br><span class="line"><span class="function">IL II <span class="title">npoi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tot++;</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) </span><br><span class="line">Tr[tot].up[i]=<span class="number">0</span>;</span><br><span class="line">Tr[tot].is=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span> </span>&#123;</span><br><span class="line">of(len);</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=len;i++) <span class="built_in">scanf</span>(<span class="string">"%1d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">R II pi=root;</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!Tr[pi].up[a[i]]) </span><br><span class="line">Tr[pi].up[a[i]]=npoi();</span><br><span class="line">pi=Tr[pi].up[a[i]];</span><br><span class="line">&#125;</span><br><span class="line">Tr[pi].is=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">bool</span> <span class="title">ask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">R II pi=root;</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!Tr[pi].up[a[i]]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pi=Tr[pi].up[a[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Tr[pi].is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">of(n);</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n;i++) in(), join();</span><br><span class="line"></span><br><span class="line">of(Q);</span><br><span class="line"><span class="keyword">while</span> ( Q -- ) &#123;</span><br><span class="line">in();</span><br><span class="line">ask() ? <span class="built_in">puts</span>(<span class="string">"Y"</span>) : <span class="built_in">puts</span>(<span class="string">"N"</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看不懂我的代码？？！ 我并没有办法。。。。。。。。。。。。。。</p><p>接下来是网上的的介绍，我就Ctrl+C+V过来了，我也没怎么看，ennnnnnnnn 大概是些定义，可以了解下</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。跟哈希表比较：</li><li>最坏情况时间复杂度比hash表好</li><li>没有冲突，除非一个key对应多个值（除key外的其他信息）</li><li>自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>虽然不同单词共享前缀，但其实trie是一个以空间换时间的算法。其每一个字符都可能包含至多字符集大小数目的指针（不包含卫星数据）。</li><li>每个结点的子树的根节点的组织方式有几种。<ul><li>果默认包含所有字符集，则查找速度快但浪费空间（特别是靠近树底部叶子）。</li><li>如果用链接法(如左儿子右兄弟)，则节省空间但查找需顺序（部分）遍历链表。</li><li>alphabet reduction: 减少字符宽度以减少字母集个数。,</li><li>对字符集使用bitmap，再配合链接法。</li></ul></li><li>如果数据存储在外部存储器等较慢位置，Trie会较hash速度慢（hash访问O(1)次外存，Trie访问O(树高)）。</li><li>长的浮点数等会让链变得很长。可用bitwise trie改进。</li></ul><p>然后 Trie 我们就讲到这里</p><hr><h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p><em>伪·自动AC机 nice</em></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><p>在学一个东西之前，我们要先了解这个东西是用来干什么的，所以呢，我现在要先说出一个最模糊的概念，也是最容易忽略的：</p><blockquote><p>AC自动机是处理字符串的有力工具</p></blockquote><p>然后我们再继续了解下它的其他概念；</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>AC自动机 </strong> <code>Aho-Corasick automation，该算法在1975年产生于贝尔实验室，是著名的多模匹配算法之一。</code></li><li><strong>常见例子</strong> <code>给出n个单词，再给出一段包含m个字符的文章，让你找出有多少个单词在文章里出现过。</code></li><li><strong>学习前提</strong> <code>要搞懂AC自动机，先得有字典树Trie和KMP模式匹配算法的基础知识。</code></li><li><strong>与KMP区分</strong> <code>KMP算法是单模式串的字符匹配算法，AC自动机是多模式串的字符匹配算法。</code></li></ul><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><h3 id="三步走"><a href="#三步走" class="headerlink" title="三步走"></a>三步走</h3><ul><li>Trie树</li><li>Fail指针</li><li>匹配</li></ul><p>Trie 我们之前讲了，所以呢，我们已经走了第一步，【开心】那么我们还有两步要走，那么当然是接着走了。。。。</p><h2 id="思想实现"><a href="#思想实现" class="headerlink" title="思想实现"></a>思想实现</h2><h3 id="我要做什么？？！"><a href="#我要做什么？？！" class="headerlink" title="我要做什么？？！"></a>我要做什么？？！</h3><ul><li>这是一个值得思考的问题，只有我们知道了要干什么我们才能去实现；</li><li>就像刚刚简介里的经典问题：<code>给出n个单词，再给出一段包含m个字符的文章，让你找出有多少个单词在文章里出现过。</code></li><li>那么我们通过解决这个子问题来解决我们要干什么这个大问题；</li></ul><p><strong>那么大家先把自己想到的做法说一下</strong></p><ul><li>​</li><li>​</li><li>​</li><li>​</li><li>​</li><li>​</li><li>​</li><li>​</li></ul><p>然后我说一下我想说的</p><h2 id="各种做法"><a href="#各种做法" class="headerlink" title="各种做法"></a>各种做法</h2><h3 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1.暴力"></a>1.暴力</h3><ul><li>首先这是个极其不错的方法，至少错误率会比较低，而且好写，再而且，这是骗分的手段之一；</li><li>然后我们考虑实现</li><li>显然枚举每个单词，然后在文章里挨个匹配</li></ul><p>code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    R II len1=<span class="built_in">strlen</span>(s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(R II j=<span class="number">1</span>;j&lt;=len;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(R II k=<span class="number">1</span>;k&lt;=len1;k++)</span><br><span class="line">            <span class="keyword">if</span>(S[j+k<span class="number">-1</span>]!=s[k]) <span class="keyword">break</span> ;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(k==len1) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br></pre></td></tr></table></figure><p><strong>复杂度：$O(n^3)$</strong> </p><h3 id="2-KMP优化"><a href="#2-KMP优化" class="headerlink" title="2.KMP优化"></a>2.KMP优化</h3><ul><li>首先这是个不错的优化手段，因为KMP可以把匹配的过程由 $O(n^2)$ 优化到 $O(n)$ </li><li>然后我们考虑实现</li><li>显然枚举每个单词，先建立该单词的next，然后在文章里挨个匹配</li></ul><p>code：</p><p><img src="/pic/2.png" alt=""></p><p><strong>复杂度：$O(n^2)$ </strong></p><h3 id="3-AC自动机优化"><a href="#3-AC自动机优化" class="headerlink" title="3.AC自动机优化"></a>3.AC自动机优化</h3><ul><li>首先名字都变长了，那肯定变 nb 了啊，</li><li>Ta把我们用 KMP 优化后的东西又优化了，妈诶，太强了</li><li>然后我们考虑实现</li><li>显然，不，一点都不显然，不然我还讲个啥啊！！！</li><li>考虑实现：比较重要，详细介绍下</li></ul><h4 id="每个新事物的开始都是异想天开"><a href="#每个新事物的开始都是异想天开" class="headerlink" title="每个新事物的开始都是异想天开"></a>每个新事物的开始都是异想天开</h4><blockquote><p>我们之前是一个个的单词去匹配，那我们能不能把所有的单词放在一起，然后一起匹配咧？？！</p><p>肯定是可以的啊，我们把文章放在外层循环，然后当前位置去匹配所有的单词就可以了啊</p></blockquote><h4 id="额，上一个好像没什么用"><a href="#额，上一个好像没什么用" class="headerlink" title="额，上一个好像没什么用"></a>额，上一个好像没什么用</h4><blockquote><p>那可咋办啊？？！</p><p>但是我们已经把单词集中到一起了啊</p><p>我们发现，如果当前有 k 个单词可以在当前位置匹配上，那这 k 个单词一定有一个公共的前缀，所以嘞，有没有想到 Trie ( • ̀ω•́ )✧</p></blockquote><h4 id="没想到也要想到。。。。"><a href="#没想到也要想到。。。。" class="headerlink" title="没想到也要想到。。。。"></a>没想到也要想到。。。。</h4><blockquote><p>如果上述 k 个单词放到了 Trie 里，然后我们把当前位置(这个位置是上一个枚举到的位置)在 Trie 中匹配，是不是就直接可以一次匹配多个串了？？</p><p>＼＼\٩(‘ω’)و//／／ </p><p> 这样我们就可以把多个单词放到一起考虑了，太棒了</p></blockquote><h4 id="但是那些和这-k-个不一样的呢"><a href="#但是那些和这-k-个不一样的呢" class="headerlink" title="但是那些和这 k 个不一样的呢"></a>但是那些和这 k 个不一样的呢</h4><blockquote><p>就不要了呗，反正我们在 Trie 上也匹配不到这几个不一样的串</p><p>A：有用吗？</p><p>B：没用。。。</p><p>A：扔！！！</p></blockquote><h2 id="code实现"><a href="#code实现" class="headerlink" title="code实现"></a>code实现</h2><h3 id="Build-fail"><a href="#Build-fail" class="headerlink" title="Build_fail"></a>Build_fail</h3><p>我们第二步是建立fail指针，所以我们需要了解fail具体是干什么的； </p><h4 id="插播一段-fail"><a href="#插播一段-fail" class="headerlink" title="插播一段 fail"></a>插播一段 fail</h4><ul><li>类似KMP中的next <code>令当前节点 A 的 fail 所指向的是节点 B ，则有 B 是A的后缀【解释】</code></li><li>这个 fail 就是AC自动机的优化之处 <code>因为它和 KMP 的 next 数组一样，可以跳转到至少不会更差的地方</code></li><li>为什么不会更差？？！ <code>我们保证了当前节点 A 的 fail 指针所指向的节点 B ，以 B 为结尾的单词串一定是以 A 为结尾的单词的后缀；至于原因，自行KMP</code></li><li>解释结束 <code>不懂快问，不然就继续了</code></li></ul><p>over</p><p>然后我们去考虑如何实现；</p><p>我们知道一个显然的事情：<code>一个字符串的后缀一定比该字符串短；</code></p><p>再根据前面说的 fail  所指向的含义；</p><p>可知，<strong>当前节点 A 的 fail 的深度一定比 A 小；</strong></p><p>然后，根据 KMP 的 next 的求法：<code>当前点 A 的 next 由 A 的前一个点 B 的 next 推出；</code></p><p>那我们放到 Trie 上，当前节点 A 的前一个节点就是 A 的父亲，所以我们 A 的 fail 是由它的父亲推出，同理，这颗 Trie 上的任何一个节点都满足这个性质；（如下图）</p><p>那么我们就可以用一种数据结构来处理：    <strong>queue </strong></p><p><img src="/pic/3.png" alt=""></p><p>每一层的构建方式都类比上一层</p><p>理解或者没理解，我现在在图上模拟一下建立 fail 的过程</p><p><img src="/pic/4.png" alt=""></p><p>(复制到画板上。。。。。。。。。。。。。)</p><p>code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 1623456</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">II up[<span class="number">27</span>];</span><br><span class="line">II is, fail;</span><br><span class="line">&#125;Tr[I];</span><br><span class="line"></span><br><span class="line">II _tot=<span class="number">-1</span>,root,n,len,ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[I];</span><br><span class="line"></span><br><span class="line"><span class="function">II <span class="title">new_one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">_tot++;</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=<span class="number">27</span>;i++) </span><br><span class="line">Tr[_tot].up[i]=<span class="number">0</span>;</span><br><span class="line">Tr[_tot].is=<span class="number">0</span>;</span><br><span class="line">Tr[_tot].fail=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> _tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fffail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;II&gt; Q;</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Tr[root].up[i]) &#123;</span><br><span class="line">Tr[Tr[root].up[i]].fail=root;</span><br><span class="line">Q.push(Tr[root].up[i]);</span><br><span class="line">&#125; <span class="keyword">else</span> Tr[root].up[i]=root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> Q.empty()) &#123;</span><br><span class="line">R II pi=Q.front(); Q.pop();</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">R II go=Tr[pi].fail;</span><br><span class="line">R II son=Tr[pi].up[i];</span><br><span class="line"><span class="keyword">if</span>(Tr[pi].up[i]) &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> Tr[go].up[i] <span class="keyword">and</span> go) &#123;</span><br><span class="line">go=Tr[go].fail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">not</span> Tr[go].up[i]) Tr[son].fail=root;</span><br><span class="line"><span class="keyword">else</span> Tr[son].fail=Tr[go].up[i];</span><br><span class="line">Q.push(son);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Tr[son].up[i]=Tr[Tr[pi].fail].up[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">root=new_one();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,a+<span class="number">1</span>);</span><br><span class="line">len=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">R II pi=root;</span><br><span class="line"><span class="keyword">for</span>(R II j=<span class="number">1</span>;j&lt;=len;j++) </span><br><span class="line">&#123;</span><br><span class="line">R II o=a[j]-<span class="string">'a'</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">not</span> Tr[pi].up[o]) Tr[pi].up[o]=new_one();</span><br><span class="line">pi=Tr[pi].up[o];</span><br><span class="line">&#125;</span><br><span class="line">Tr[pi].is++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fffail();</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,a+<span class="number">1</span>);</span><br><span class="line">len=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">R II pi=root;</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=len;i++) </span><br><span class="line">&#123;</span><br><span class="line">R II o=a[i]-<span class="string">'a'</span>+<span class="number">1</span>;</span><br><span class="line">R II pr=pi;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> Tr[pi].up[o] <span class="keyword">and</span> pi) pi=Tr[pi].fail;</span><br><span class="line">pi=Tr[pi].up[o];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">not</span> pi) pi=root;</span><br><span class="line"><span class="keyword">while</span> (pr <span class="keyword">and</span> Tr[pr].is&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">ans+=Tr[pr].is;</span><br><span class="line">Tr[pr].is=<span class="number">-1</span>;</span><br><span class="line">pr=Tr[pr].fail;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几十年前的代码了，勿喷。。。。。。。。。。。。。。。</p><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p><em>简单应用在OI里当然是做题了。。。。。。。。。。。。。。</em></p><ul><li>T1 luogu AC自动机(简单版)and(加强版)</li><li>T2 HDU 3341 Lost’s revenge</li><li>T3 HDU 2896 病毒侵袭</li><li>T4 并没有T4，略略略，以上的T1理解，T2，T3。。。。算了</li></ul><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><ul><li>T1 裸的AC自动机（都模板了好不，刚讲的）</li><li>T2 。。。。。。。。。。。。</li><li>T3 。。。。。。。。。。。。。。</li></ul><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>当然有PPT的</p>]]></content>
      
      
        <tags>
            
            <tag> algorithm of OI </tag>
            
            <tag> Tire </tag>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>luogu P1169 [ZJOI2007]棋盘制作</title>
      <link href="/2018/04/15/luogu%20P1169%20%5BZJOI2007%5D%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C/"/>
      <url>/2018/04/15/luogu%20P1169%20%5BZJOI2007%5D%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>这个题是悬线法的练习题，十分 nice，我第一次做的时候，十分尬，问的白学家，写了好久，然后才过，刚刚写了下，还OK吧，1A</p><p>写一下这个题的思路</p><p>给定一个 01 矩阵，找一个最大的正方形矩阵，和一个长方形矩阵，要求这两个矩阵的 01 是相见分布的就像样例里的这个图，正方形就是红圈这个矩阵</p><p><img src="/pic/1.png" alt=""></p><p>至于为什么用悬线法，我们考虑一个合法的 01 矩阵，我们可以选择其中的任意列作为我们所找的线，然后这条线上的任何一个点的 $l[i][j]$ 和 $r[i][j]$ 的最小值就是这个矩阵的长，即</p><p>$$l_{矩阵}=min\{l[i][j]\} (i,j)∈所选线$$</p><p>$$r_{矩阵}=min\{r[i][j]\} (i,j)∈所选线$$</p><p>设我们选的线是褐色格子，那么 $l_{矩阵}$ 就是最左侧的那一列，没有 $r_{矩阵}$ </p><p>然后我们就可以用悬线法来处理 $l[i][j], r[i][j]$ 然后 $for$ 就OK了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 2010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">of</span> <span class="params">(R T &amp;a)</span> </span>&#123;</span><br><span class="line">R <span class="keyword">char</span> c=getchar (); R T w=<span class="number">1</span>, p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>; c=getchar (); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123; p=p*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar (); &#125;</span><br><span class="line">a=w*p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">Big</span> <span class="params">(R T &amp;a,R T b)</span> </span>&#123; a&lt;b?a=b:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">Sma</span> <span class="params">(R T &amp;a,R T b)</span> </span>&#123; a&gt;b?a=b:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(R T &amp;a,R T &amp;b)</span> </span>&#123; R T c=b;b=a;a=c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------- Peipei -------------------- */</span></span><br><span class="line"></span><br><span class="line">II n,m,ans1,ans2;</span><br><span class="line">II a[I][I], l[I][I], r[I][I];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line"></span><br><span class="line">of(n); of(m);</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(R II j=<span class="number">1</span>;j&lt;=m;j++) of(a[i][j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line"><span class="keyword">for</span>(R II j=<span class="number">2</span>;j&lt;=m;j++)</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==(a[i][j<span class="number">-1</span>]^<span class="number">1</span>)) l[i][j]=l[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(R II j=m<span class="number">-1</span>;j;j--) </span><br><span class="line"><span class="keyword">if</span>(a[i][j]==(a[i][j+<span class="number">1</span>]^<span class="number">1</span>)) r[i][j]=r[i][j+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(R II j=<span class="number">1</span>,len=<span class="number">1</span>,ll,rr;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">len=<span class="number">1</span>, ll=l[<span class="number">1</span>][j], rr=r[<span class="number">1</span>][j];</span><br><span class="line">Big(ans1,min(len,ll+rr+<span class="number">1</span>)*min(len,ll+rr+<span class="number">1</span>));</span><br><span class="line">Big(ans2,len*(ll+rr+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==(a[i<span class="number">-1</span>][j]^<span class="number">1</span>)) &#123;</span><br><span class="line">len++;</span><br><span class="line">Sma(ll,l[i][j]);</span><br><span class="line">Sma(rr,r[i][j]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">len=<span class="number">1</span>;</span><br><span class="line">ll=l[i][j];</span><br><span class="line">rr=r[i][j];</span><br><span class="line">&#125;</span><br><span class="line">Big(ans1,min(len,ll+rr+<span class="number">1</span>)*min(len,ll+rr+<span class="number">1</span>));</span><br><span class="line">Big(ans2,len*(ll+rr+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,ans1,ans2);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> luogu </tag>
            
            <tag> solution </tag>
            
            <tag> problem of OI </tag>
            
            <tag> 悬线法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>悬线法</title>
      <link href="/2018/04/15/%E6%82%AC%E7%BA%BF%E6%B3%95/"/>
      <url>/2018/04/15/%E6%82%AC%E7%BA%BF%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>Q：是什么呢？</p><p>A：就是很nb的东西；</p><p>Q：干什么的呢？</p><p>A：就是用来求最优矩阵的；</p><hr><p>首先我们有一个矩阵，然后我们需要一个最优矩阵；<br>我一般能想到的就是n^3暴力前缀和，昨天还写了个注意事项呢；<br>但是，今天就被怼死了；</p><p>那么我们就要学一下悬线法了；</p><blockquote><p>顾名思义，就是悬好多线，然后左右扩展，得到最优矩阵；</p></blockquote><p>O(nm)；<br>然后呢，我们先要找悬线；<br>枚举每一行/列，令当前点 $a[i][j]$；<br>令o为只是该行状态下的 $a[i][j]$ 能扩展的最远距离;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if  a[i][j] and a[i-1][j] -&gt; can make a team;</span><br><span class="line">    go; </span><br><span class="line">    then l[i][j]=min(l[i][j],o); </span><br><span class="line">else </span><br><span class="line">    go again;</span><br><span class="line">    then l[i][j]=o, h[i][j]=new line;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>就是说，我们一个点可以顺接左侧的点，那么我这个点的左侧最远合法距离=左侧的点左侧最远合法距离+1</p><p>否则就是当前一个点，即 =1</p><p>然后就好了；<br>$r[i][j]$ 的方式和这个一样；<br>所以就每次都跟新下答案；</p><p>至于例题可以看<a href="http://pretend-fal.ml/2018/04/15/luogu%20P1169%20[ZJOI2007]%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C/" target="_blank" rel="noopener">这个</a></p><hr><p>Q：还是不太懂。。。。。。。</p><p>A：gun~</p>]]></content>
      
      
        <tags>
            
            <tag> algorithm of OI </tag>
            
            <tag> 悬线法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树的重心</title>
      <link href="/2018/04/10/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"/>
      <url>/2018/04/10/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/</url>
      <content type="html"><![CDATA[<p>我们先介绍一棵树的重心的概念：</p><blockquote><p>以所有节点为根，重心的最大子树最小， 最大子树指子树节点数最多</p></blockquote><p>然后我们就可以用一个所谓的树形DP解决这个事情</p><p>就是我们先随便找一个 $root$ 然后 <code>dfs(root)</code> 每到一个点，计算其最大子树，然后比较，挑选出最大子树最小的那个节点，所有节点处理完后，就找到了重心</p><p>至于一个节点怎么算他的最大子树</p><p>在 dfs 中该节点的子树不用多说，但是，这并不是全部，我们现在要求得是，以当前节点为根的最大子树，那么这个节点还有一个子树就是他的父亲，请自行画图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">get_root</span><span class="params">(R II x,R II fat)</span> </span>&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span>; W[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(R II i=head[x],go;i;i=aa[i].up)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[go=aa[i].to] || go==fat) <span class="keyword">continue</span> ;</span><br><span class="line">        get_root(go,x);</span><br><span class="line">        Big(W[x],siz[go]);</span><br><span class="line">        siz[x]+=siz[go];</span><br><span class="line">    &#125;</span><br><span class="line">    Big(W[x],SIZ-siz[x]);</span><br><span class="line">    <span class="keyword">if</span>(W[x]&lt;W[root]) root=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而他父亲作为子树时的大小就是所有节点减去当前节点所代表的的子树大小。。。。。。。。。</p><p>emmmmmmmmmmmmmmm</p><p>还是自行画图</p>]]></content>
      
      
        <tags>
            
            <tag> algorithm of OI </tag>
            
            <tag> DP </tag>
            
            <tag> 树的重心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>点分治</title>
      <link href="/2018/04/10/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
      <url>/2018/04/10/%E7%82%B9%E5%88%86%E6%B2%BB/</url>
      <content type="html"><![CDATA[<p>这个知识点我就写过两道题，一个模板，一个聪聪可可</p><p>然后呢，我现在要写一下我对这个题的理解</p><p>首先呢，这个算法是用来解决一些树上路径问题的，我做的这两道题都是关于树上路径长度统计的</p><p>我们先有一颗树，然后树边上有边权</p><p><img src="https://s7.postimg.org/uh7w6qwff/image.png" alt=""></p><p>比如这棵树，我们要查询长度为 $6$ 的路径条数，然后我们选取一个节点，接下来我们遍历这个节点的子树，然后记录当前节点到达每个子树中每个节点的路径长度，最后分别组合，即为所有两端在当前节点的子树中的路径的所有情况</p><p>所以我们有个方法就是枚举每个点，然后去搞，但是显然，点的选择会影响最后的复杂度，比如一条链，如果每次都选顶端，那么就是 $O(n^2)$ 但是如果每次都选中间，就是 $O(nlogn)$， 可以自行画图理解下</p><p>我们处理完当前节点后，会处理该节点的所有子树，而且处理子树的时候所需要的点就是该子树，不会受到别的子树的影响，因为所有跨子树的情况我们都已经在当前节点处理好了，这样子我们处理子树的复杂度就和子树大小有关了</p><p>然后我们可以看出，如果当前节点的最大子树越小，最后的复杂度就越低，那么我们就会去想一下重心[^至于不会重心的同学，请在文末查看]，然后我们找到重心之后，会去计算路径，再然后，我们会去处理这个重心的子树，处理这个子树的方式同理，找到这颗子树的重心，然后像刚刚一样处理，不过在处理某一个子树的重心时，我们会用现在所处理树的 $size$ 进行处理，就是比如上面的图，处理 $3$ 这个子树时，大小是 $3$ </p><p>至于代码，可以参考另一篇blog：<a href="http://pretend-fal.ml/2018/04/10/luogu%20P2634%20[%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F]%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF/#post.more" target="_blank" rel="noopener">luogu P2634 [国家集训队]聪聪可可</a></p><p><a href="http://pretend-fal.ml/2018/04/10/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/" target="_blank" rel="noopener">重心学习</a></p>]]></content>
      
      
        <tags>
            
            <tag> algorithm of OI </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>luogu P2634 [国家集训队]聪聪可可</title>
      <link href="/2018/04/10/luogu%20P2634%20%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF/"/>
      <url>/2018/04/10/luogu%20P2634%20%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF/</url>
      <content type="html"><![CDATA[<p>这个题呢，就是点分治，因为首先题面可以解释为<code>求有多少条路径长度是 3 的倍数，同一个点长度为 0，不同点算两次</code> 然后就点分治好了，这个题总体来讲是比较裸的，毕竟我这种只去年写过一次点分治的模板题得蒟蒻都看出来了。。。。。。。。。</p><p>然后边长 $mod 3$ 存起来就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 41000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span>  T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">of</span> <span class="params">(R T &amp;a)</span> </span>&#123;</span><br><span class="line">    R <span class="keyword">char</span> c=getchar (); R T w=<span class="number">1</span>, p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>; c=getchar (); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123; p=p*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar (); &#125;</span><br><span class="line">    a=w*p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">Big</span> <span class="params">(R T &amp;a,R T b)</span> </span>&#123; a&lt;b?a=b:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">Sma</span> <span class="params">(R T &amp;a,R T b)</span> </span>&#123; a&gt;b?a=b:<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------- Peipei -------------------- */</span></span><br><span class="line"></span><br><span class="line">II _tot,n,all,root,Inf=<span class="number">1e9</span>,PI=<span class="number">3</span>,SIZ;</span><br><span class="line">II head[I], W[I], inq[I], siz[I], kc[<span class="number">4</span>], nu[<span class="number">4</span>], ck[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UI</span> &#123;</span> II to,up,w; &#125; aa[I];</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">join</span><span class="params">(R II x,R II y,R II z)</span> </span>&#123;</span><br><span class="line">    aa[++_tot]=(UI) &#123;y,head[x],z&#125;; head[x]=_tot;</span><br><span class="line">    aa[++_tot]=(UI) &#123;x,head[y],z&#125;; head[y]=_tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">Q_SIZ</span><span class="params">(R II x,R II fat)</span> </span>&#123;</span><br><span class="line">    SIZ++;</span><br><span class="line">    <span class="keyword">for</span>(R II i=head[x],go;i;i=aa[i].up)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[go=aa[i].to] || go==fat) <span class="keyword">continue</span> ;</span><br><span class="line">        Q_SIZ(go,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">get_root</span><span class="params">(R II x,R II fat)</span> </span>&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span>; W[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(R II i=head[x],go;i;i=aa[i].up)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[go=aa[i].to] || go==fat) <span class="keyword">continue</span> ;</span><br><span class="line">        get_root(go,x);</span><br><span class="line">        Big(W[x],siz[go]);</span><br><span class="line">        siz[x]+=siz[go];</span><br><span class="line">    &#125;</span><br><span class="line">    Big(W[x],SIZ-siz[x]);</span><br><span class="line">    <span class="keyword">if</span>(W[x]&lt;W[root]) root=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">ROOT</span><span class="params">(R II x)</span> </span>&#123; SIZ=<span class="number">0</span>; Q_SIZ(x,<span class="number">0</span>); root=<span class="number">0</span>; get_root(x,<span class="number">0</span>); &#125;</span><br><span class="line"><span class="function">IL II <span class="title">gcd</span><span class="params">(R II a,R II b,R II c=<span class="number">0</span>)</span> </span>&#123; <span class="keyword">while</span> (b) &#123; c=b;b=a%b;a=c; &#125; <span class="keyword">return</span> a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">get_dep</span><span class="params">(R II x,R II fat,R II len)</span> </span>&#123;</span><br><span class="line">    kc[len]++;</span><br><span class="line">    <span class="keyword">for</span>(R II i=head[x],go;i;i=aa[i].up)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[go=aa[i].to] || go==fat) <span class="keyword">continue</span> ;</span><br><span class="line">        get_dep(go,x,(len+aa[i].w)%PI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">ADD</span><span class="params">(R II x=<span class="number">0</span>,R II y=<span class="number">0</span>,R II z=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    x=ck[<span class="number">0</span>]*kc[<span class="number">0</span>]+ck[<span class="number">1</span>]*kc[<span class="number">2</span>]+ck[<span class="number">2</span>]*kc[<span class="number">1</span>];</span><br><span class="line">    y=ck[<span class="number">0</span>]*kc[<span class="number">1</span>]+ck[<span class="number">1</span>]*kc[<span class="number">0</span>]+ck[<span class="number">2</span>]*kc[<span class="number">2</span>];</span><br><span class="line">    z=ck[<span class="number">0</span>]*kc[<span class="number">2</span>]+ck[<span class="number">1</span>]*kc[<span class="number">1</span>]+ck[<span class="number">2</span>]*kc[<span class="number">0</span>];</span><br><span class="line">    ck[<span class="number">0</span>]+=kc[<span class="number">0</span>]; kc[<span class="number">0</span>]=<span class="number">0</span>; nu[<span class="number">0</span>]+=x;</span><br><span class="line">    ck[<span class="number">1</span>]+=kc[<span class="number">1</span>]; kc[<span class="number">1</span>]=<span class="number">0</span>; nu[<span class="number">1</span>]+=y;</span><br><span class="line">    ck[<span class="number">2</span>]+=kc[<span class="number">2</span>]; kc[<span class="number">2</span>]=<span class="number">0</span>; nu[<span class="number">2</span>]+=z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(R II x)</span> </span>&#123;</span><br><span class="line">    ck[<span class="number">0</span>]=<span class="number">1</span>; ck[<span class="number">1</span>]=ck[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(R II i=head[x],go;i;i=aa[i].up)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[go=aa[i].to]) <span class="keyword">continue</span> ;</span><br><span class="line">        get_dep(go,x,aa[i].w);  ADD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">solve</span><span class="params">(R II x)</span> </span>&#123;</span><br><span class="line">    inq[x]=<span class="number">1</span>;  get_ans(x);</span><br><span class="line">    <span class="keyword">for</span>(R II i=head[x],go;i;i=aa[i].up)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[go=aa[i].to]) <span class="keyword">continue</span> ;</span><br><span class="line">        ROOT(go); solve(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    of(n);</span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">1</span>,x,y,z;i&lt;n;i++) &#123;</span><br><span class="line">        of(x); of(y); of(z); z%=PI;</span><br><span class="line">        join(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    W[<span class="number">0</span>]=Inf;</span><br><span class="line">    ROOT(<span class="number">1</span>); solve(root);</span><br><span class="line"></span><br><span class="line">    nu[<span class="number">0</span>]=nu[<span class="number">0</span>]*<span class="number">2</span>+n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d/%d\n"</span>,nu[<span class="number">0</span>]/gcd(nu[<span class="number">0</span>],n*n),n*n/gcd(nu[<span class="number">0</span>],n*n));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> luogu </tag>
            
            <tag> solution </tag>
            
            <tag> problem of OI </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>luogu P1941 飞扬的小鸟</title>
      <link href="/2018/04/09/luogu%20P1941%20%E9%A3%9E%E6%89%AC%E7%9A%84%E5%B0%8F%E9%B8%9F/"/>
      <url>/2018/04/09/luogu%20P1941%20%E9%A3%9E%E6%89%AC%E7%9A%84%E5%B0%8F%E9%B8%9F/</url>
      <content type="html"><![CDATA[<p>这个题，一眼傻逼 DP，</p><p>状态：</p><p>​                    $f[i][j]$ 代表到达第 $i$ 行第 $j$ 列的最少点击数</p><p>有转移方程：</p><p>​                    $$f[i][j] = min\{f[i-1][j-up[i-1]*k]+k,f[i-1][j+dow[i-1]]\}$$</p><p>因为首先我们可以从前一行的格子向上跳 up[i-1] 格，使之到达当前行，由于向上跳没有限制[^坑点1]，所以要乘 $k$ ，而同样可以向下跳 dow[i-1] 格到达当前行，但是只能跳一次，不需要乘</p><p>比如这个图</p><p><img src="https://s7.postimg.org/94m5kfh3f/image.png" alt="image.png"></p><p> 我们当前第 $i$ 行的褐色格子，可以由 $i-1$ 行的 $j+dow[i-1]$ 黄色格子下降 $dow[i-1]$ 格到达，也可以由 $j-up[i-1]$ 的红色格子向上跳一次 $up[i-1]$ 格到达，也可以由 $j-up[i-1]<em>2$ 的蓝色格子跳 $up[i-1]</em>2$ 格到达</p><p>至于没有到达的情况，注意是输出穿越了几个柱子[^坑点2]，而不是通过了几列格子</p><p>所以就直接枚举转移就好了，我这里用的是滚动数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 10100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">of</span> <span class="params">(R T &amp;a)</span> </span>&#123;</span><br><span class="line">    R <span class="keyword">char</span> c=getchar (); R T w=<span class="number">1</span>, p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>; c=getchar (); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123; p=p*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar (); &#125;</span><br><span class="line">    a=w*p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">Big</span> <span class="params">(R T &amp;a,R T b)</span> </span>&#123; a&lt;b?a=b:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">Sma</span> <span class="params">(R T &amp;a,R T b)</span> </span>&#123; a&gt;b?a=b:<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------- Peipei -------------------- */</span></span><br><span class="line"></span><br><span class="line">II n,m,k,ans=<span class="number">1e9</span>,Inf=<span class="number">1e9</span>;</span><br><span class="line">II f[I], g[I], dow[I], up[I], bot[I], top[I], is[I];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("1.in","r",stdin);</span></span><br><span class="line"></span><br><span class="line">    of(n); of(m); of(k);</span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        of(up[i]), of(dow[i]), top[i]=m+<span class="number">1</span>;</span><br><span class="line">    top[n+<span class="number">1</span>]=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">1</span>,x;i&lt;=k;i++) &#123;</span><br><span class="line">        of(x); x++; is[x]=<span class="number">1</span>;</span><br><span class="line">        of(bot[x]); of(top[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">1</span>,flag;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        is[i]+=is[i<span class="number">-1</span>];</span><br><span class="line">        swap(f,g);</span><br><span class="line">        <span class="keyword">for</span>(R II j=<span class="number">1</span>;j&lt;=m;j++) f[j]=Inf;</span><br><span class="line">        <span class="keyword">for</span>(R II j=bot[i]+<span class="number">1</span>,to;j&lt;top[i];j++) &#123;</span><br><span class="line">            to=j+up[i];</span><br><span class="line">            <span class="keyword">if</span>(to&lt;top[i+<span class="number">1</span>]) Sma(f[to],g[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(R II j=m;j&gt;=m-up[i];j--) Sma(f[m],g[j]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(R II j=up[i]+<span class="number">1</span>;j&lt;=m;j++) Sma(f[j],f[j-up[i]]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(R II j=m;j&gt;=m-up[i];j--) Sma(f[m],f[j]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(R II j=bot[i]+<span class="number">1</span>,to;j&lt;top[i];j++) &#123;</span><br><span class="line">            to=j-dow[i];</span><br><span class="line">            <span class="keyword">if</span>(to&gt;bot[i+<span class="number">1</span>]) Sma(f[to],g[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(R II j=<span class="number">1</span>;j&lt;=bot[i+<span class="number">1</span>];j++) f[j]=Inf;</span><br><span class="line">        <span class="keyword">for</span>(R II j=m;j&gt;=top[i+<span class="number">1</span>];j--) f[j]=Inf;</span><br><span class="line"></span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(R II j=bot[i+<span class="number">1</span>]+<span class="number">1</span>;j&lt;top[i+<span class="number">1</span>];j++)</span><br><span class="line">            <span class="keyword">if</span>(f[j]&lt;Inf) &#123; flag=<span class="number">1</span>; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n%d\n"</span>,is[i]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=m;i++) Sma(ans,f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1\n%d\n"</span>,ans);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> luogu </tag>
            
            <tag> solution </tag>
            
            <tag> problem of OI </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>see this</title>
      <link href="/2018/04/09/see%20this/"/>
      <url>/2018/04/09/see%20this/</url>
      <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2018/03/28/9XfYV0.gif" alt=""></p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Silence!!"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Hello everyone,I am Peipei."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> mood </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算是分割线吧</title>
      <link href="/2018/04/09/%E7%AE%97%E6%98%AF%E5%88%86%E5%89%B2%E7%BA%BF%E5%90%A7/"/>
      <url>/2018/04/09/%E7%AE%97%E6%98%AF%E5%88%86%E5%89%B2%E7%BA%BF%E5%90%A7/</url>
      <content type="html"><![CDATA[<p>ennnnnnnnnnn</p><p>接下来还是要 noip ，虽然尬，但是也没办法，然后这篇 blog 就是记录下我现在想说的，ennnnnnnnnnnnnn</p><p>首先我接下来的 blog 肯定大部分是算法介绍，题解，以及时不时地写一下自己想写的</p><p>然后当然要放下剩下的其他事情，还有文化课，eaaaaaaaaQAQ</p><p>过几天就 APIO 了，然而没有分到一个考区，十分尬</p><p>我的 blog 不能用百度搜到，mmp</p><p>好吧，没什么了，要做题了</p><p>奥对还有，今天省一们就算是退役了，都回家放假了，YY家太远，现在在机房</p><p>ennnnnnn，怎么讲呢，祝各位 AFO 开心吧</p>]]></content>
      
      
        <tags>
            
            <tag> mood </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博弈论</title>
      <link href="/2018/04/08/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
      <url>/2018/04/08/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
      <content type="html"><![CDATA[<p>一．巴什博奕（Bash Game）：<br>首先我们来玩一个比较古老的报数游戏。A和B一起报数，每个人每次最少报一个,最多报4个。轮流报数,看谁先报到30.<br>如果不知道巴什博弈的可能会觉得这个是个有运气成分的问题，但是如果知道的人一定知道怎样一定可以赢。<br>比如A先报数的话,那么B一定可以赢(这里假定B知道怎么正确的报数)<br>B可以这样报数,每次报5-k(A)个数,其中k(A)是A报数的个数这样的话没一次<br>两人报完数之后会变成5 10 15 20 25 30这样是不是B一定会赢呢?是不是有一种被欺骗的感觉呢?好吧下面我们来看看这个原理。我们先看下一个一眼就能看出答案的例子 比如说我们报到5(4+1),每次报最多报4个,最少报1个.那么是不是后者一定可以赢呢？答案是肯定的。好了到这巴什博弈的精髓基本就OK了。<br>那么如果我们要报到n+1,每次最多报n个,最少报1个的话,后者一定能够赢。<br>现在我们需要报数到n,而每次最多报数m个,最少报数1个.我们可以化成这样<br>n = k*(1+m)+r(0 &lt;= r &lt;= m）这样的话如果r不等于0那么先手一定会赢，为什么呢？首先先手报r个,那么剩下k倍(1+m)个数,那么我们每次报数1+m-k(B)个数就一定能保证最后剩下1+m个,那么就到了上面我们说的那个了,先手就一定会赢,如果r=0那么后手一定会赢,道理一样的。<br>到这巴什博弈也就介绍完了,知道这个道理之后我们也可以去骗小朋友了。-_-//<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr, val) memset(arr, val, sizeof(arr))  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//freopen("Input.txt", "r", stdin);  </span></span><br><span class="line">    <span class="keyword">int</span> N, num, limit;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);  </span><br><span class="line">    <span class="keyword">while</span>(N--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;num, &amp;limit);  </span><br><span class="line">        <span class="keyword">if</span>(num % (limit + <span class="number">1</span>) != <span class="number">0</span>) <span class="comment">//必胜局面  </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Win\n"</span>);  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Lose\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;        </span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>二．威佐夫博奕（Wythoff Game）：<br>   这种博弈比前面一种要稍微复杂一点。我们来看下下面这个游戏。<br>   有两堆火柴棍,每次可以从某一堆取至少1根火柴棍(无上限)，或者从两堆取相同的火柴棍数。最后取完的是胜利者。好了,如果你不知道这个博弈定理,对于小数目的火柴棍数,可能还能推出来,但是如果火柴棍数一多,就不行了。看了下面的这个介绍,你也会有一种被骗的感觉。<br>   首先我们知道两堆火柴是没有差别的,也就是说第一堆有a根,第二堆有b根和第一堆有b根,第二堆有a根是一样的结果。<br>   我们用一个二维的状态（a,b)来记录当前剩下的火柴数，表示第一堆剩下a根火柴,第二堆剩下b根火柴。同样我们假设两个人的编号是A和B，且A先取。<br>那么如果某个人遇到了这样的状态(0,0)那么也就是说这个人输了。这样的状态我们叫做奇异状态,也可以叫做失败态。<br>那么接下来的几个失败态为(1,2),(3,5),(4,7),(6,10),(8,13)……<br>我们用a[i]表示失败态中的第一个,b[i]表示失败态中的第二个.(i从0开始).<br>那么我们可以看到b[i] = a[i]+i;（i &gt;= 0）,a[i]是前面的失败态中没有出现过的最小的整数<br>下面我们可以得到三个基本的结论。<br>  1.每个数仅包含在一个失败态中<br>  首先我们知道a[k]是不可能和前面的失败态中的a[i],b[i]重复的(这点由a[i]的得到可以知道)<br>b[k] = a[k]+k &gt; a[k-1]+k&gt;a[k-1]+k-1+1&gt;a[k-1]+(k-1) = b[k-1]&gt;a[k-1]这样我们知道每个数仅在一个失败态中。<br>  2.每个失败态可以转到非失败态。<br> 加入当前的失败态为(a,b)，那么如果我们只在一堆中取的话,肯定会变成非失败态(这点由第一点可以保证),如果从两堆同时取的话,由于每个失败态的差是不一样的,所以也不可能得到一个失败态。也就是说一个失败态不管你怎么取,都会得到一个非失败态。<br>   3.每个非失败态都可以转到一个失败态<br>对于这个结论,首先我们要知到每个状态(a,b)要么a = a[i],要么b = b[i].(每个数都出现在一个失败态中),下面我们分两种情况来讨论<br>   I.a = a[i].如果b = a的话那么一次取完就变成了(0,0).如果b &gt; b[i]的话,那么我们从第二堆中取走b-b[i]就变成了一个失败态。如果b &lt; b[i].那么我们从两堆中同时取走a-a[b-a[i]]这样得到失败态(a[b-a[i]],a[b-a[i]]+b-a[i])(a[i] = a)<br>   II.b = b[i].如果a &gt; a[i]那么我们从第一堆中取走a-a[i]根火柴.<br>              如果a &lt; a[i].这里又分两种情况。第一是a = a<a href="k &lt; i">k</a><br>那么我们从第二堆取走b - b[k]就行了。<br>第二是a = b[k]这样的话由于两堆火柴是没有区别的,所以我们把b变成a[k]就行了,也即是从第二堆火柴中取走b - a[k]就变成了失败态<br>至于怎么判断一个状态是否是失败态.我们可以用下面的方法来判断(本人暂时还不会证明)<br>  a[i] = <a href="这里的中括号表示向下取整">i*(1+√5)/2</a>   b[i] = a[i]+i;<br>  那么这就是一个失败态<br>代码如下：<br>​<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr, val) memset(arr, val, sizeof(arr))  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//freopen("Input.txt", "r", stdin);  </span></span><br><span class="line">    <span class="keyword">int</span> num1, num2, tmp; <span class="comment">//第一堆剩的数量为num1,第二堆剩num2  </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;num1, &amp;num2) != EOF)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(num1 &gt; num2)  </span><br><span class="line">            swap(num1, num2);   </span><br><span class="line">        tmp = <span class="built_in">floor</span>((num2 - num1) * (<span class="number">1</span> + <span class="built_in">sqrt</span>(<span class="number">5.0</span>)) / <span class="number">2.0</span>); <span class="comment">//黄金分割  </span></span><br><span class="line">        <span class="keyword">if</span>(tmp == num1) <span class="built_in">printf</span>(<span class="string">"Lose\n"</span>); <span class="comment">//奇异局势必败  </span></span><br><span class="line">        <span class="keyword">else</span>    <span class="built_in">printf</span>(<span class="string">"Win\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三．尼姆博奕（Nimm Game）：</p><p>指的是这样的一个博弈游戏，目前有任意堆石子，每堆石子个数也是任意的，双方轮流从中取出石子，规则如下：<br>1)每一步应取走至少一枚石子；每一步只能从某一堆中取走部分或全部石子；<br>2)如果谁取到最后一枚石子就胜。<br>也就是尼姆博弈（Nimm Game）。<br>必败局面：也叫奇异局势。无论做出何出操作，最终结果都是输的局面。必败局面经过2次操作后，可以达到另一个必败局面。<br>必胜局面：经过1次操作后可以达到必败局面。<br>即当前局面不是必败局面就是必胜局面，而必胜局面可以一步转变成必败局面。<br>最终状态：<br>（1）最后剩下一堆石子；（必胜局面）<br>（2）剩下两堆，每堆一个；（必败局面）<br>（3）当石子剩下两堆，其中一堆只剩下1颗，另一堆剩下多于n颗石子时，当前取的人只需将多于1颗的那一堆取出n-1颗，则局面变为刚才提到的必败局面。（必胜局面）<br>判断当前局势是否为必胜（必败）局势：<br>1）把所有堆的石子数目用二进制数表示出来，当全部这些数按位异或结果为0时当前局面为必败局面，否则为必胜局面；<br>2）在必胜局面下，因为所有数按位异或的结果是大于零的，那么通过一次取，将这个（大于其它所有数按位异或的结果的）数下降到其它所有数按位异或的结果，这时局面就变为必败局面了。<br>定理：一组自然数中必然存在一个数，它大于等于其它所有数按位异或的结果。<br>证明：原命题等价于，设a1＾a2＾… ＾an=p，p≠0时，必存在k，使得ak＾p&lt;ak（当p=0时，对于任意的k，有ak＾p=ak）。<br>设p的最高位是第q位，则至少存在一个k，使得ak的第q位也是1，而ak＾p的第q位为0，所以ak^p&lt;ak<br>    补缀一点，（a＾b）＾b=a＾（b＾b）=a＾0=a，所以ak＾p相当于“其它所有数按位异或的结果”。<br>例1：2 45 45<br>45＾45＝0,45和45的异或等于0。<br>例 2：3 3 6 9<br>局势（3,6，9）因为3＾6＾9不等于0，所以这是一个必胜局势。<br>　3　011<br>＾6　110<br>　5　101　<br>即从第3堆中的9个中取走9－5＝4个，则（3,6，9）－＞（3,6，5），3＾6＾5＝0，故（3,6，5）为奇异局势，即从必胜局势转变成必败局势。<br>代码如下：<br>​<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">int</span> temp[ <span class="number">20</span> ]; <span class="comment">//火柴的堆数  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, n, min;  </span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; n; i++ )  </span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp[ i ]; <span class="comment">//第i个火柴堆的数量  </span></span><br><span class="line">        min = temp[ <span class="number">0</span> ];  </span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; n ; i++ )  </span><br><span class="line">            min = min^temp[ i ]; <span class="comment">//按位异或  </span></span><br><span class="line">        <span class="keyword">if</span>( min == <span class="number">0</span> )  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Lose"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输  </span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Win"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//赢  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> algorithm of OI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性筛</title>
      <link href="/2018/04/08/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
      <url>/2018/04/08/%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
      <content type="html"><![CDATA[<p><strong>好像有叫做线性素数筛的东西，而且我不知道我的是不是；</strong></p><p><strong>至于为怎么写这篇文章，其实就是背不过，然后以后复习用；</strong></p><p><strong>鉴于以上目的，我就直接上代码了，挺好背的，背过就好了；</strong></p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 2000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">II n,_tot;</span><br><span class="line">II op[I], is[I];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">2</span>;i&lt;=I<span class="number">-100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!is[i]) op[++_tot]=i;</span><br><span class="line"><span class="keyword">for</span>(R II j=<span class="number">1</span>;j&lt;=_tot &amp;&amp; op[j]*i&lt;=I<span class="number">-100</span>;j++) &#123;</span><br><span class="line">is[op[j]*i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%op[j]==<span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); sss();</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=_tot;i++) </span><br><span class="line"><span class="keyword">if</span>(op[i]&gt;=n&amp;&amp;(!is[i])) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,op[i]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>by pretend-fal</strong></p><p><strong>END;</strong></p>]]></content>
      
      
        <tags>
            
            <tag> algorithm of OI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gcd&amp;exgcd</title>
      <link href="/2018/04/08/gcd&amp;exgcd/"/>
      <url>/2018/04/08/gcd&amp;exgcd/</url>
      <content type="html"><![CDATA[<p><strong>其实这个东西可以背板子的；</strong></p><p><strong>所以我打算直接上板子：</strong></p><hr><p>gcd<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">II <span class="title">gcd</span><span class="params">(R II a,R II b,R II c=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (b) &#123; c=b; b=a%b; a=c; &#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>exgcd<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">R II x,y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(R II x,R II y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>; y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">exgcd(a%b,b);</span><br><span class="line">R II x2=x,y2=y;</span><br><span class="line">x=y2;</span><br><span class="line">y=x2-y2*(a/b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>by pretend-fal</strong></p><p><strong>END;</strong></p>]]></content>
      
      
        <tags>
            
            <tag> algorithm of OI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并查集</title>
      <link href="/2018/04/08/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2018/04/08/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>并查集，顾名思义，就是把元素并到一个集合里，然后还可以查找某个元素在哪一个集合里；**</p><hr><p><strong>这其实就是并查集了，思想很简单，而且很好写，不过很少会有题专门考并查集，但是，不可否认的是，并查集是一个极为有用的辅助算法，或者说是思想，再或者是一种实现方式；</strong></p><hr><p><strong>并查集有几个主要操作：</strong></p><p><strong>Ⅰ 初始化：我们会把每一个点放入一个单独的集合，即fa[x]=x，代表x所在的这个集合的代表元素是x；</strong></p><p><strong>Ⅱ 查询：我们每一个集合的表现形式是一颗树，而所有的集合便表现为一个森林，所以我们递归地查询x所在的集合，一旦找到某一个点是一个集合的代表元素，那么我们就可以认为x与这个点在一个集合（而且一定在一个集合），并且这个集合是现在找到的这个点所代表的集合；</strong></p><p><strong>Ⅲ 合并： 假设我们希望把元素A与元素B合并到一个集合中，那么我们可以将这两个点所在的集合的代表元素合并到一个集合，至于这个过程，详情见代码；</strong></p><hr><p><img src="http://www.k-xzy.xyz/wp-content/uploads/2018/02/20170802213231813.jpeg" alt=""></p><p><strong>声明：本博客图片来自网络；</strong></p><p><strong>查询：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                         <span class="comment">//查找我（x）的掌门</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=x;                            <span class="comment">//委托 r 去找掌门</span></span><br><span class="line">    <span class="keyword">while</span> (pre[r]!=r)                   <span class="comment">//如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =）</span></span><br><span class="line">    r=pre[r] ;                          <span class="comment">// r 就接着找他的上级，直到找到掌门为止。</span></span><br><span class="line">    <span class="keyword">return</span>  r ;                         <span class="comment">//掌门驾到~~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>合并：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>                   <span class="comment">//我想让虚竹和周芷若做朋友</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y);           <span class="comment">//虚竹的老大是玄慈，芷若MM的老大是灭绝</span></span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)                           <span class="comment">//玄慈和灭绝显然不是同一个人</span></span><br><span class="line">    pre[fx]=fy;                         <span class="comment">//方丈只好委委屈屈地当了师太的手下啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>还有一个路径压缩，比较重要，它一定程度上决定了并查集的效率；</strong></p><p><strong>所谓路径压缩，就是把原来是一个长链的树处理成一颗深度较浅的树，以至于查询时不至于递归太多次，其实就是一个小细节问题；</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">II <span class="title">find</span> <span class="params">(R II x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> fa[x]=find(fa[x]); </span><br><span class="line">    <span class="comment">//这个地方我们由 esle return find(fa[x]) 改为了</span></span><br><span class="line">    <span class="comment">//return fa[x]=find(fa[x]);</span></span><br><span class="line">    <span class="comment">//就是每次查询，我们就会把没有并在代表元素上的节点并到代表元素上；</span></span><br><span class="line">    <span class="comment">//这样就可以使得树的深度较浅了；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果大概就是这样的：</strong></p><p><img src="http://www.k-xzy.xyz/wp-content/uploads/2018/02/20170802214359295.jpeg" alt=""></p><hr><p><strong>然后依旧是完整代码：</strong></p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 123456</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">of</span><span class="params">(R II &amp;a)</span> </span>&#123;</span><br><span class="line">R <span class="keyword">char</span> c=getchar (); R II w=<span class="number">1</span>, p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>; c=getchar (); &#125;</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>) &#123; p=p*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar (); &#125;</span><br><span class="line">a=w*p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------- Peipei -------------------- */</span></span><br><span class="line"></span><br><span class="line">II fa[I];</span><br><span class="line">II n,m;</span><br><span class="line"></span><br><span class="line"><span class="function">II <span class="title">find</span> <span class="params">(R II x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> fa[x]=find(fa[x]); </span><br><span class="line">  <span class="comment">//这个地方我们由 esle return find(fa[x]) 改为了</span></span><br><span class="line">  <span class="comment">//return fa[x]=find(fa[x]);</span></span><br><span class="line">  <span class="comment">//就是每次查询，我们就会把没有并在代表元素上的节点并到代表元素上；</span></span><br><span class="line">  <span class="comment">//这样就可以使得树的深度较浅了；</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(R II x,R II y)</span> </span>&#123; fa[x]=y; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">of(n); of(m);</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line"> <span class="comment">//初始化；</span></span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>,x,y,z;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">of(x); of(y); of(z);</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>) join(find(y),find(z));</span><br><span class="line">    <span class="comment">//注意一定要传代表元素，保证正确性；</span></span><br><span class="line">    <span class="comment">//不明白可以画图试一下；</span></span><br><span class="line"><span class="keyword">else</span> find(y)==find(z) ? <span class="built_in">printf</span>(<span class="string">"Y\n"</span>) : <span class="built_in">printf</span>(<span class="string">"N\n"</span>) ;</span><br><span class="line">    <span class="comment">//查询是否在一个集合中；</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>by pretend-fal;</strong></p><p><strong>END;</strong></p>]]></content>
      
      
        <tags>
            
            <tag> algorithm of OI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MST</title>
      <link href="/2018/04/08/MST/"/>
      <url>/2018/04/08/MST/</url>
      <content type="html"><![CDATA[<a id="more"></a><p><strong>我们有一个无向图，然后要求生成一棵边权之和最小的树</strong></p><p><strong>首先，我们可以暴力，枚举每一条边选不选，然后计算边权和，更新答案，必定会TLE，这是显然的；</strong></p><p><strong>那么我们需要一种较为高效的算法来解决这种问题，这时候，我们就可以学一下MST（最小生成树）的Kruskal算法了</strong></p><p><strong>这个算法用到了一些贪心的思想，就是我们每次选当前待选的边权最小的那条边，如果这条边符合性质，我们就把它加入到树中，否则，我们换下一条边，一直重复这个过程，知道我们加入了n-1条边（n为节点数）；</strong></p><p><strong>那么显然我们是要排序的，根据边权大小由小到大排序，每次取出一条边，判断是否合法的方法是用并查集，如果两个端点在一个集合中，说明这两个点一定在此之前由一些更短的边在连接其它的点的时候将这两个点连入了一个集合，所以当前边是没必要选的，且不可以选，不然违反了树的性质，有了环，如果两个端点不在一个集合，我们就把这两个点连入一个集合，处理完当前的边后，继续下一条边，直至结束；</strong></p><p><strong>完整代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 223456</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">II n,m,ans;</span><br><span class="line">II fa[I];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    II x,y,flow;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a1,node a2)</span><br><span class="line">    &#123; <span class="keyword">return</span> a1.flow&lt;a2.flow; &#125;</span><br><span class="line">&#125;aa[I];</span><br><span class="line"></span><br><span class="line"><span class="function">II <span class="title">find</span><span class="params">(II x)</span> </span>&#123; <span class="keyword">return</span> fa[x]==x ? x : fa[x]=find(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(II x,II y)</span> </span>&#123; fa[x]=y; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(II i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        II x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        aa[i].x=x;aa[i].y=y;</span><br><span class="line">        aa[i].flow=z;</span><br><span class="line"><span class="comment">//选择结构体存边，保证不会出现乱的情况；</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(aa+<span class="number">1</span>,aa+m+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//贪心排序；</span></span><br><span class="line">    <span class="keyword">for</span>(II i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line"><span class="comment">//初始化，每个点都分别在一个不同的集合里；</span></span><br><span class="line">    <span class="keyword">for</span>(II i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(find(aa[i].x)!=find(aa[i].y)) &#123;</span><br><span class="line"><span class="comment">//判断是否在一个集合里；</span></span><br><span class="line">            join(find(aa[i].x),find(aa[i].y));</span><br><span class="line"><span class="comment">//连入树中；</span></span><br><span class="line">            ans+=aa[i].flow;</span><br><span class="line"><span class="comment">//ans加上当前边权；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于时间紧迫，这篇文章没有图片解释，见谅；<br>by pretend-fal；<br>END；</p>]]></content>
      
      
        <tags>
            
            <tag> algorithm of OI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tarajn</title>
      <link href="/2018/04/08/Tarjan/"/>
      <url>/2018/04/08/Tarjan/</url>
      <content type="html"><![CDATA[<p>Tarjan是多种算法的总称，因为Tarjan这个人太牛X了，那我们今天就来看一看Tarjan神的算法之一 ：Tarjan求割边割点；</p><p>首先我们要清晰什么是割边割点：<br>​<br>割点：<br>​    首先我们有一张连通图：<br><img src="http://img.blog.csdn.net/20170731210422085?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJldGVuZF9mYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>​            </p><p>对于这张图，显然它是一张联通图，那么割点的定义就是：“某一个点A，若删除这个点并且删去这个点所练的边，那么这张图的强联通分量增多”；</p><p>若删除点3及相连的边后，强联通分量就变成了{1,2}和{4,5,6} (点3已删除)；    </p><p>那么割边呢？         </p><p>显然，根据割点的定义，割边的定义可以推得：“某一条边B，若删除该边，则所在图的强联通分量增多”；这个定义和割点的定义极其相似；<br>​<br>则，在上图中，若删除3—4这条边，改图的强联通分量数目改变，由{1,2,3,4,5,6}—&gt;{1,2,3}和{4,5,6}；所以，该图中3—4这条边就是该图的割边；<br>​<br>同样，一重点内容个图中的割点割边有时候不止一个；<br>​<br>​<br>而Tarjan是怎么求割边割点呢？？！<br>用一个dfs的思想，建一棵搜索树；<br>然后我们有一个结论：<br>​<br> 割点：<1> 若这个点A是根节点，那么只要它有两棵及以上的子树，那么它必为割点；<br>​        <2> 若这个点A不是根节点，则如果它所有儿子的LOW都小于等于节点A的DFN，则节点A是割点；<br>​<br>​<br>割边同样可以类比割点的性质；<br>割边：<1> 若该节点A，与它的子节点B，若节点B的LOW小于A的DFN，则A——B是割边；<br>​<br>割点：</1></2></1></p><p>证明<1>：若该根节点A含有两棵及以上子树，则删去节点A，其子树必定成为独立的强联通分量，且数量增多；反之，若只含有一棵子树，则节点A删除后对原图联通性毫无影响；</1></p><p>证明<2>：若节点A非根节点，且没有一个儿子的LOW小于A的DFN，即没有回边指向节点A的祖先，所以以节点A为根的子树是通过节点A来连接到整棵树上的，所以删除节点A后，该子树脱落，强联通分量增加；<br>​<br>割边：</2></p><p>证明<1>：若节点A的儿子B，LOW[B]&gt;DFN[A] ，则以B为根节点的子树是由A——B这条边连接到整棵树中的，所以删除A——B，该子树脱落，强联通分量增加；</1></p><p>作为一个程序员，我们看重的不能只有思想，还要有代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> child=<span class="number">0</span>;</span><br><span class="line">DFN[x]=LOW[x]=++_num;</span><br><span class="line"><span class="keyword">for</span>(R II i=head[x];i;i=aa[i].up)</span><br><span class="line">&#123;</span><br><span class="line">R II go=aa[i].to;</span><br><span class="line"><span class="keyword">if</span>(!DFN[go])&#123;</span><br><span class="line">child++;</span><br><span class="line">fa[go]=x;</span><br><span class="line">Tarjan(go);</span><br><span class="line"><span class="keyword">if</span>(LOW[go]&gt;DFN[x]) ...</span><br><span class="line"><span class="comment">// x 和 go所连的边是一条割边；</span></span><br><span class="line"> </span><br><span class="line">LOW[x]=min(LOW[go],LOW[x]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(LOW[go]&gt;=DFN[x]&amp;&amp;x!=root)  bit[x]=<span class="number">1</span>;</span><br><span class="line"><span class="comment">// x 是根时 ，x 是一个割点； </span></span><br><span class="line"><span class="keyword">if</span>(x==root&amp;&amp;child&gt;<span class="number">1</span>)  bit[x]=<span class="number">1</span>;</span><br><span class="line"><span class="comment">// x 不是根时 ，x 是割点； </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(go!=fa[x])&#123;</span><br><span class="line">LOW[x]=min(LOW[x],DFN[go]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">// 原图不一定是一个强联通分量；</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!DFN[i])&#123;</span><br><span class="line">root=i;</span><br><span class="line">Tarjan(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>by pretend-fal；<br>END；</p>]]></content>
      
      
        <tags>
            
            <tag> algorithm of OI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ST表</title>
      <link href="/2018/04/08/ST%E8%A1%A8/"/>
      <url>/2018/04/08/ST%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>求最大值  </p><p>f ( i , j ) 是从 i 到 $i+2^j$ 的最大值，ennnnnnnnnnnnnn，  </p><p>首先我们用倍增的思想  </p><p>$$ f[j][i]=max(f[j][i-1],f[j+(o&gt;&gt;1)][i-1]) $$  </p><p>因为当前区间可以分为前半段和后半段，那么当前区间的最大值就是两端最大值的 $max$  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 123456</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">II f[I][<span class="number">30</span>];</span><br><span class="line">II n,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f[i][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=n;i++)</span><br><span class="line"><span class="comment">// 这里(1&lt;&lt;j)&lt;=n；</span></span><br><span class="line">&#123;</span><br><span class="line">R II o=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">for</span>(R II j=<span class="number">1</span>;j&lt;=n-o+<span class="number">1</span>;j++)</span><br><span class="line"><span class="comment">// 这里要j&lt;=n-o+1；</span></span><br><span class="line">f[j][i]=max(f[j][i<span class="number">-1</span>],f[j+(o&gt;&gt;<span class="number">1</span>)][i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line">R II l,r,ans=<span class="number">-1e9</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">R II o=<span class="built_in">log</span>(r-l+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">ans=max(f[l][o],f[r-(<span class="number">1</span>&lt;&lt;o)+<span class="number">1</span>][o]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm of OI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手工开栈</title>
      <link href="/2018/04/08/%E6%89%8B%E5%B7%A5%E5%BC%80%E6%A0%88/"/>
      <url>/2018/04/08/%E6%89%8B%E5%B7%A5%E5%BC%80%E6%A0%88/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">256</span> &lt;&lt; <span class="number">20</span>; <span class="comment">// 256MB  </span></span><br><span class="line"><span class="keyword">char</span> p = (<span class="keyword">char</span>)<span class="built_in">malloc</span>(size) + size;  </span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"movl %0, %%esp\n"</span> :: <span class="string">"r"</span>(p));</span><br></pre></td></tr></table></figure><p>这段代码里可能有些关键字游戏地方没办法用，【摊手】</p>]]></content>
      
      
        <tags>
            
            <tag> tools of OI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对拍</title>
      <link href="/2018/04/08/%E5%AF%B9%E6%8B%8D/"/>
      <url>/2018/04/08/%E5%AF%B9%E6%8B%8D/</url>
      <content type="html"><![CDATA[<p><strong>首先我们有三个程序，bao_li.cpp，zheng_jie.cpp，data.cpp</strong></p><p><strong>全部运行后有三个exe</strong></p><p><strong>然后写一个bat</strong></p><p>————————————-~~~————————————</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:again</span><br><span class="line">data.exe &gt; input.txt</span><br><span class="line">bao_li.exe &lt; input.txt &gt; bao_li.txt</span><br><span class="line">zheng_jie.exe &lt;input.txt &gt; zheng_jie.txt</span><br><span class="line">fc bao_li.txt zheng_jie.txt</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> errorlevel <span class="number">1</span> <span class="keyword">goto</span> again</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p><strong>下面的是每一行的解释</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">:again</span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line">data.exe &gt; input.txt</span><br><span class="line"><span class="comment">// 从data中产生数据，放到input.txt中</span></span><br><span class="line">bao_li.exe &lt; input.txt &gt; bao_li.txt</span><br><span class="line"><span class="comment">// 把input.txt中的数据通过bao_li.exe运行，并把运行数据放到bao_li.txt中</span></span><br><span class="line">zheng_jie.exe &lt;input.txt &gt; zheng_jie.txt</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line">fc bao_li.txt zheng_jie.txt</span><br><span class="line"><span class="comment">// 比较运行出的两组数据</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> errorlevel <span class="number">1</span> <span class="keyword">goto</span> again</span><br><span class="line"><span class="comment">// 若相同回到开始</span></span><br><span class="line">pause</span><br><span class="line"><span class="comment">// 否则暂停</span></span><br></pre></td></tr></table></figure><p><strong>这个文件可以用.txt写好，然后后缀改为.bat</strong></p><p>————————————~~~————————————–</p><p><strong>by pretend-fal</strong></p><p><strong>END</strong></p>]]></content>
      
      
        <tags>
            
            <tag> tools of OI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>problem1</title>
      <link href="/2018/04/08/problem1/"/>
      <url>/2018/04/08/problem1/</url>
      <content type="html"><![CDATA[<h1 id="lxw’s-adventures"><a href="#lxw’s-adventures" class="headerlink" title="lxw’s adventures"></a>lxw’s adventures</h1><table><thead><tr><th style="text-align:center">题目名称</th><th style="text-align:center">桌布</th><th style="text-align:center">颜色</th><th style="text-align:center">银行卡</th></tr></thead><tbody><tr><td style="text-align:center">文件名</td><td style="text-align:center">tablecloth.cpp/c/pas</td><td style="text-align:center">color.cpp/c/pas</td><td style="text-align:center">card.cpp/c/pas</td></tr><tr><td style="text-align:center">时间限制</td><td style="text-align:center">1s</td><td style="text-align:center">1s</td><td style="text-align:center">1s</td></tr><tr><td style="text-align:center">空间限制</td><td style="text-align:center">128MB</td><td style="text-align:center">128MB</td><td style="text-align:center">128MB</td></tr></tbody></table><h1 id="桌布"><a href="#桌布" class="headerlink" title="桌布"></a>桌布</h1><h5 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h5><p>​    围绕着一张桌子，lxw 开始了 Ta 的装饰</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Ta 先在这张桌子上放了一张桌布，这张桌布呢，上面画了张图，就是那种 OI 中的有点和边的图，然后呢，这个图是一个联通块，而且边是无向的，然而 lxw 不喜欢一个联通块的图，Ta 想通过破坏一些边来使得这个图变成 $k$ 个联通块，然而每条边都是有脾气的 $w$，假设这个脾气值是 $w_i$ 那么 lxw 想要把这条边拆掉就要忍受 $w_i$ 的怒气，所以呢，lxw 想知道为了达到 Ta 的目的，至少需要忍受多少怒气，然而 lxw 那么可爱，所以这个艰难的任务就交给你来完成了 QAQ</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>​    第一行三个数，$n,m,k$</p><p>​    接下来 $m$ 行，每行三个数 $x_i , y_i , z_i$ 代表 $x_i$ 和 $y_i$ 之间有一条怒气值为 $z_i$ 的边</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>​    一行一个数，即 lxw 最少所需要忍受的怒气值</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p><code>9 15 4</code><br><code>1 2 154704354</code><br><code>1 3 623440960</code><br><code>1 4 10828032</code><br><code>1 5 622633654</code><br><code>1 6 114426928</code><br><code>1 7 109034202</code><br><code>1 8 104024998</code><br><code>1 9 98657592</code><br><code>3 1 8297</code><br><code>6 1 1115</code><br><code>9 3 27244</code><br><code>1 9 7165</code><br><code>4 3 2057</code><br><code>1 2 18349</code><br><code>2 5 19431</code>  </p><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p><code>213547088</code></p><p><em>数据范围与约定</em></p><ul><li>$20 \%   n\leq 20,m\leq 20$</li><li>$60\%   n\leq10^3,m\leq2\times10^3$</li><li>$100\%   n\leq10^5 , m\leq2\times10^5   $怒气值$\leq 10^9$</li></ul><hr><h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><h5 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h5><p>​    终于，lxw 在你的帮助下用最小的花费做好了桌布，但是这时，天上掉下来了一张银行卡 wow，而且还有一张纸条，写着<code>恭喜您成为我们第233666位幸运用户，这张卡您可以随便刷，但是三天后会被收回</code> ，于是lxw变成了三天的有钱人，就买了一个带有一个好多颜色的长条布</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    这张长条布可以看做一个长度为 $n$ 的格子，且只有一行，lxw 看着这张布，一会可能就把其中某个格子的颜色换成了另一种颜色，一会可能问你在 <code>[l,r]</code> 这个区间中，所有的颜色为 $c$ 的格子中，最靠近当前区间中点的格子的位置</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>​    第一行，一个 $n$ ，接下来 $n$ 个数，为每个格子初始颜色，接下来一行，一个 $Q$ ，表示 lxw 的操作个数，再接下来 $Q$ 行，形式为 <code>C x c</code> 或者<code>Q l r c</code> 表示把 $x$ 这个位置的颜色改为 $c$ ，或者询问 <code>[l,r]</code> 这个区间 $c$ 这个颜色(如题)</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>​    对于每个 $Q$ 操作，输出一个数，表示位置(如题)，如果距离一样，输出靠左的位置，如果没有，输出$-1$</p><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><p><code>4</code><br><code>1 8 5 4</code><br><code>6</code><br><code>C 4 1</code><br><code>Q 2 4 3</code><br><code>Q 2 2 8</code><br><code>C 3 0</code><br><code>Q 3 3 1</code><br><code>C 1 0</code>   </p><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><p><code>-1</code><br><code>2</code><br><code>-1</code>  </p><p><em>数据范围与约定</em></p><ul><li>$30\% \,\,\,\,n\leq100 ,m\leq100$</li><li>$60\% \,\,\,\,n\leq10^3, m\leq10^3$</li><li>$100\% \,\,\,\, n\leq10^5 m\leq10^5 \,\,\,\, 保证 r+l 是偶数且 c\leq9$</li></ul><hr><h1 id="银行卡"><a href="#银行卡" class="headerlink" title="银行卡"></a>银行卡</h1><h5 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h5><p>​    三天过去了，终于银行卡要被收走了，lxw 十分伤心</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    在银行卡消失的那一瞬间，lxw 看了一眼这银行卡号，发现这张银行卡的号码每一位都是∈<code>[0,9]</code>，而且对于每一个<code>[0,9]</code>中的数字，下一位只能是某几位数字之一，比如：$3$ 后面只能是 $0,1,5$ 之一，那么号码中只能存在<code>...30...</code> 、<code>...31...</code> 、<code>...35...</code>这样的形式，现在 lxw 告诉你了每一位后面可以跟的数字集合，请你告诉 Ta 可能有多少种号码满足这个限制</p><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>​    第一行一个 $n$ ，表示号码长度，接下来 $10$ 行，每行开始有一个数 $k$ 接下来 $k$ 个数，表示如题，$10$ 行分别代表 <code>[0,9]</code> 中的每个数的信息</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>​    一行，一个数，即方案数，由于 $ans$ 可能很大，要求对 $20010827$ 取模后输出</p><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><p><code>3</code><br><code>2 0 3</code><br><code>2 0 1</code><br><code>2 5 1</code><br><code>3 0 6 4</code><br><code>1 1</code><br><code>2 2 4</code><br><code>0</code><br><code>2 7 2</code><br><code>2 0 3</code><br><code>2 2 4</code>    </p><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><p><code>33</code></p><p><em>数据范围与约定</em></p><ul><li>$10\% \,\,\,\, n\leq5$</li><li>$60\% \,\,\,\, n\leq10^6$</li><li>$100\% \,\,\,\, n\leq10^{18} $</li></ul><hr><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h2><h2 id="BY-Peipei"><a href="#BY-Peipei" class="headerlink" title="BY Peipei"></a>BY Peipei</h2><hr><hr><h1 id="lxw’s-adventures-solution"><a href="#lxw’s-adventures-solution" class="headerlink" title="lxw’s adventures solution"></a>lxw’s adventures solution</h1><h2 id="桌布（teblecloth）"><a href="#桌布（teblecloth）" class="headerlink" title="桌布（teblecloth）"></a>桌布（teblecloth）</h2><p>​    是不是一下子就想到了生成树？？！</p><p>​    其实就是生成树+贪心</p><p>​    首先我们从大到小加边，直到再加一条边就由 $k$ 个联通块变为 $k-1$ 个联通块为止</p><p>​    然后呢，已经加进去的边是不属于我们要删的边集的，那么对于剩下的没加进去的边，只有一部分是需要删的，为什么呢？？！</p><p>​    如果说，在剩下的边中，由一些边所连的两个点已经在一个联通块了，那么这条边不应该删，因为这条边删了不会影响联通块数量，但是会是 $ans$ 变大，与我们的意志相违背，所以，我们要把没有加进去的边中，已经连接两个属于同一联通块的边加进图里</p><p>​    做完这些后还没有加进去的边就是需要删的边</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LO long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 1023546</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">of</span> <span class="params">(R T &amp;a)</span> </span>&#123;</span><br><span class="line">    R <span class="keyword">char</span> c=getchar (); R T w=<span class="number">1</span>, p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>; c=getchar (); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123; p=p*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar (); &#125;</span><br><span class="line">    a=w*p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------- Peipei -------------------- */</span></span><br><span class="line"></span><br><span class="line">II n,END,all,m,k;</span><br><span class="line">LO ans;</span><br><span class="line">II fa[I];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">POI</span> &#123;</span></span><br><span class="line">II x,y;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (POI a1,POI a2) </span><br><span class="line">&#123; <span class="keyword">return</span> a1.x==a2.x ? a1.y&lt;a2.y : a1.x&lt;a2.x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">map</span> &lt;POI,II&gt; nu;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UI</span> &#123;</span></span><br><span class="line">II x,y,w;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (UI a1,UI a2) </span><br><span class="line">&#123; <span class="keyword">return</span> a1.w&lt;a2.w; &#125;</span><br><span class="line">&#125; aa[I];</span><br><span class="line"></span><br><span class="line"><span class="function">IL II <span class="title">find</span><span class="params">(R II x)</span> </span>&#123; <span class="keyword">return</span> fa[x]==x ? x : fa[x]=find(fa[x]) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"tablecloth.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"tablecloth.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    of(n); of(m); of(k);</span><br><span class="line">    R II len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=m;i++) </span><br><span class="line">&#123;</span><br><span class="line">    of(aa[len].x); of(aa[len].y); of(aa[len].w);</span><br><span class="line">    <span class="keyword">if</span>(aa[len].x&gt;aa[len].y) swap(aa[len].x,aa[len].y);</span><br><span class="line">    <span class="keyword">if</span>(nu.count((POI) &#123;aa[len].x,aa[len].y&#125;)) &#123;</span><br><span class="line">    aa[nu[(POI) &#123;aa[len].x,aa[len].y&#125;]].w+=aa[len].w;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">nu[(POI) &#123;aa[len].x,aa[len].y&#125;]=len;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m=len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=m;i++) ans+=aa[i].w;</span><br><span class="line"></span><br><span class="line">sort(aa+<span class="number">1</span>,aa+m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i; all=n;</span><br><span class="line"><span class="keyword">for</span>(R II i=m;i;i--)</span><br><span class="line">&#123;</span><br><span class="line">R II x=find(aa[i].x), y=find(aa[i].y);</span><br><span class="line"><span class="keyword">if</span>(x!=y) &#123;</span><br><span class="line"><span class="keyword">if</span>(all==k) &#123; END=i; <span class="keyword">break</span> ; &#125;</span><br><span class="line">fa[x]=y; all--;</span><br><span class="line">&#125;</span><br><span class="line">ans-=aa[i].w; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=END;i++) </span><br><span class="line"><span class="keyword">if</span>(find(aa[i].x)==find(aa[i].y)) ans-=aa[i].w;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="颜色（color）"><a href="#颜色（color）" class="headerlink" title="颜色（color）"></a>颜色（color）</h2><p>​    一行 $n$ 个格子，要求支持以下操作：</p><ul><li><p>单点修改</p></li><li><p><code>[l,r]</code> 中给定颜色最靠中间的位置</p></li></ul><p>  那么我们开 $c$ 棵线段树，分别维护每个颜色，那么这个题就变为了这样子</p><ul><li><p>[x] 单点修改就是在原来颜色中删节点，在新的颜色中添加节点  </p></li><li><p>[x] 在给定的颜色的线段树中查询最靠中间的位置</p></li><li><p><code>[l,r]</code> 找中间位置，分为<code>[l,mid]</code> 找最右端位置 和 <code>[mid,r]</code> 找最左端位置</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 100100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">of</span> <span class="params">(R T &amp;a)</span> </span>&#123;</span><br><span class="line">    R <span class="keyword">char</span> c=getchar (); R T w=<span class="number">1</span>, p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>; c=getchar (); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123; p=p*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar (); &#125;</span><br><span class="line">    a=w*p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------- Peipei -------------------- */</span></span><br><span class="line"></span><br><span class="line">II now,n,Q,l,r,ppc;</span><br><span class="line">II c[I];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    II l,r,lp,rp;</span><br><span class="line">    Tree () &#123;l=r=<span class="number">0</span>; lp=<span class="number">1e9</span>; rp=<span class="number">-1e9</span>;&#125;</span><br><span class="line">    <span class="keyword">friend</span> Tree <span class="keyword">operator</span> + (Tree a1,Tree a2) &#123;</span><br><span class="line">        R Tree c;</span><br><span class="line">        c.l=a1.l; c.r=a2.r;</span><br><span class="line">        c.lp=min(a1.lp,a2.lp);</span><br><span class="line">        c.rp=max(a1.rp,a2.rp);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">ag</span><span class="params">()</span> </span>&#123;lp=<span class="number">1e9</span>; rp=<span class="number">-1e9</span>;&#125;</span><br><span class="line">&#125; Tr[<span class="number">10</span>][I*<span class="number">4</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f Tr[now][o]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls Tr[now][o&lt;&lt;1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs Tr[now][o&lt;&lt;1|1]</span></span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">build_t</span><span class="params">(R II o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f.l==f.r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[f.l]==now) f.lp=f.rp=f.l;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ls.l=f.l; ls.r=(f.l+f.r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    rs.l=ls.r+<span class="number">1</span>; rs.r=f.r;</span><br><span class="line">    <span class="keyword">build_t</span>(o&lt;&lt;<span class="number">1</span>); <span class="keyword">build_t</span>(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    f=ls+rs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">del</span><span class="params">(R II o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f.l==f.r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ppc) f.ag();</span><br><span class="line">        <span class="keyword">else</span> f.lp=f.rp=f.l;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ls.r&gt;=l) del(o&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(rs.l&lt;=r) del(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    f=ls+rs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IL Tree <span class="title">query</span><span class="params">(R II o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f.l&gt;=l &amp;&amp; f.r&lt;=r) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=ls.r) <span class="keyword">return</span> query(o&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;=rs.l) <span class="keyword">return</span> query(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(o&lt;&lt;<span class="number">1</span>)+query(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"color.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"color.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    of(n);</span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">1</span>;i&lt;=n;i++) of(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(now=<span class="number">0</span>;now&lt;=<span class="number">9</span>;now++) &#123;</span><br><span class="line">        Tr[now][<span class="number">1</span>].l=<span class="number">1</span>; Tr[now][<span class="number">1</span>].r=n;</span><br><span class="line">        <span class="keyword">build_t</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    R <span class="keyword">char</span> opt; R II ll,rr,x,to,mid;</span><br><span class="line">    of(Q); <span class="keyword">while</span> ( Q -- ) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="string">'C'</span>) &#123;</span><br><span class="line">            of(x); of(to);</span><br><span class="line">            l=r=x;</span><br><span class="line">            ppc=<span class="number">0</span>; now=c[x]; del(<span class="number">1</span>);</span><br><span class="line">            c[x]=to;</span><br><span class="line">            ppc=<span class="number">1</span>; now=c[x]; del(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            of(ll); of(rr); of(now);</span><br><span class="line">            mid=(ll+rr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class="line">            l=ll; r=mid; ll=query(<span class="number">1</span>).rp;</span><br><span class="line">            l=mid; r=rr; rr=query(<span class="number">1</span>).lp;</span><br><span class="line">            <span class="keyword">if</span>(ll==<span class="number">-1e9</span> &amp;&amp; rr==<span class="number">1e9</span>) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ll==<span class="number">-1e9</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rr);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rr==<span class="number">1e9</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ll);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid-ll&lt;=rr-mid) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ll);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="银行卡（card）"><a href="#银行卡（card）" class="headerlink" title="银行卡（card）"></a>银行卡（card）</h2><p>​    $n$ 个数字，每个位置是<code>[0,9]</code> 中任意一个，且<code>[0,9]</code> 中每一位的下一位都属于一个固定集合那么我们设</p><blockquote><p>f ( i , j ) 表示 到第 i 个位置，结尾是 j 这个数字的方案数</p></blockquote><p>显然 假设 $k$ 的下一位集合是 $S_k$ 那么转移为 <code>f[i][j] += f[i-1][k]</code> 其中 $j$ ∈ $S_k$</p><p>但是，$n &lt;=1000000000000000000$</p><p>那么，考虑优化</p><p>由于是线性递推，则可以用矩阵乘法加速  </p><p>初始矩阵为 <code>a[0][j]=1</code> 其中 $j ∈ [0,9]$  </p><p>基底矩阵为 <code>c[i][j]=1</code> 其中 $i ∈ [0,9], j ∈ S_i$  </p><p>最后矩阵乘法快速幂即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LO long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 100100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 20010827</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">of</span> <span class="params">(R T &amp;a)</span> </span>&#123;</span><br><span class="line">    R <span class="keyword">char</span> c=getchar (); R T w=<span class="number">1</span>, p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>; c=getchar (); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123; p=p*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar (); &#125;</span><br><span class="line">    a=w*p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function">IL <span class="keyword">void</span> <span class="title">inc</span> <span class="params">(T &amp;a,T b)</span> </span>&#123; a+=b;a&gt;=PI?a-=PI:<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------- Peipei -------------------- */</span></span><br><span class="line"></span><br><span class="line">LO n;</span><br><span class="line">II ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NU</span> &#123;</span></span><br><span class="line">    II a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    NU () &#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);&#125;</span><br><span class="line">    <span class="keyword">friend</span> NU <span class="keyword">operator</span> * (NU a1,NU a2) &#123;</span><br><span class="line">        R NU d;</span><br><span class="line">        <span class="keyword">for</span>(R II i=<span class="number">0</span>,x;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(R II j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">        <span class="keyword">for</span>(R II k=<span class="number">0</span>;k&lt;=<span class="number">9</span>;k++) &#123;</span><br><span class="line">            x=<span class="number">1l</span>l*a1.a[i][k]*a2.a[k][j]%PI;</span><br><span class="line">            inc(d.a[i][j],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a,c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"card.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"card.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    of(n);</span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">0</span>,len,x;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">    <span class="keyword">for</span>(of(len);len;len--)</span><br><span class="line">        of(x), c.a[i][x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) a.a[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(n--;n;n&gt;&gt;=<span class="number">1</span>, c=c*c)</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>) a=a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(R II i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) inc(ans,a.a[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2>]]></content>
      
      
        <tags>
            
            <tag> problem of OI </tag>
            
            <tag> tests </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HEOI2018颓废记</title>
      <link href="/2018/04/08/HEOI2018%E9%A2%93%E5%BA%9F%E8%AE%B0/"/>
      <url>/2018/04/08/HEOI2018%E9%A2%93%E5%BA%9F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<script>if("CAFO"==prompt("请输入密码")){alert("正确");}else{alert("错误");location="http://pretend-fal.ml/";}</script><p><strong>2018 - 4 - 7</strong></p><p>今天啊，我们省选完了，然后呢，我的所谓的希望也结束了，嗯。。。。。大家大概都没有考到自己想要的成绩，YY也翻了，真的十分可惜，他进队我是可以服的，但是他翻了，昨天考完试，他们从教练哪里看完分，然后回来了他在床上一坐说翻了，我突然感觉替他难受，真的经历过这个事情的人才能体会到，去年noip之后，我的状态和心情，没有人真的和我谈过，lxw也根本不了解这些东西，真的什么都要自己承受，真的心累，然而差点抑郁，庆幸自己还开心地活着，然鹅我昨天考了100，我预期的保守分是115，但是结局十分尬，吃晚饭的时候，陪yy聊了一顿饭，真的感觉大家都一样，都背着自己给自己的压力以及外界给的压力，其实吧，考试而已，但是，总会出现比较，这真的十分令人恶心，还好，我昨天考试的时候，心态一直没崩，今天也是，我昨天的成绩是别人告诉我的，我没有看，今天才知道，非正式选手是没有名字的，只有编号，比如我是227，真的是日了狗，我弄到最后，连个名都没留下，去TMD，今天的T1我写了费用流，费用xjb搞，然后调了调过了四个样例，开心，而且担心，真的怕A不掉，然而我现在都不知道我T1多少分，非正式选手没人权啊，mmp，我刚刚看了分，才10分，，，完了，总分才110，还没人家D1的分高呢，，，，，突然人生失去了希望，不知道该说啥，我好想有一个cp，然后可以去找依靠，</p><p><strong>updata 2018 - 4 - 8</strong></p><p>今天回了学校，ennnnnnnnnnnn 昨天就回来了，只是到的比较晚，在路上和cdy谈了谈所谓的OI经验，然后到了学校后，大家都十分低沉，毕竟是翻了，然后今天跑完操，开了个小会，大概分析了下，还给了几句安慰，但是我觉得没有人会因为这几句安慰去真的放下，对啊，省一的就可以APIO和CTSC之后退役了，然而我还要苟到noip，真的是可怕，河北省太可怕了，垄断，真的是垄断，我自己的noip分太低了，以至于总和D1+D2+noip才142分，然而他们最高分都260多了，其实吧，这些真的会让人有些压抑，但是还是要面对，就像noip之后，没有人会特别在意你的感受，毕竟大家还是看成绩说话的，那天和YY说我noip的时候，他说我是翻车，真的，那一刻我觉得还是会有人去认可我的，但是，当时心情特别好，毕竟我最怕别人认为我的能力不足以到达至少平均水平，然而没有人进队这个事情已经发生了，什么都过去了这种话，真的在我们这些亲身经历过省选失败的人的口中讲出来，全是假的，谁会真的说过去就过去啊，大家真的是都顶着足够的压力，在前面的有学校的压力，在后面的有自己的压力，这方面谁也不会差给谁，大家都够辛苦，而这个世界又太残酷了，真的世界在疯狂，我们如果在这么顺其自然真的是会挂的，要和世界gang，垃圾搜狗输入法，连gang都打不出来</p>]]></content>
      
      
        <tags>
            
            <tag> day by day </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
